#+TITLE: Paraparity's Literate Emacs Configuration
#+PROPERTY: header-args :tangle yes

* Overview
  I've maintained my Emacs configuration in a number of styles across the years, each having its own strengths and
  weaknesses. I've even declared configuration bankruptcy a few times. Presently I'm experimenting with a literate
  configuration where I hope to better capture the intent and reasons for my configuration settings. My hope is that
  this improves my experience maintaining my configuration, and that it also helps others understand what these configs
  do.

  I invite your feedback openly. Welcome aboard my ship of Theseus.

** House Keeping

*** Variable Naming Convention
	As is common among Emacsers, I've opted to adopt a naming scheme that identifies personal contributions and adds a
	bit of individual flare. Considering the name I go by is =Paraparity=, you'll notice a number of names prefixed with
	=TT/=. This represents a so-called =pair of T's= playing off of the =parity= portion of my handle.


* General Settings

** Add Some Output Commentary
   When tangled, all of these source blocks become an =.el= file. I'd still like that to be more friendly than just a
   bunch of configuration code, so let's keep my old =init.el= header around.

   #+begin_src emacs-lisp
	 ;;; configuration.el --- paraparity's Emacs configuration file
	 ;;
	 ;;; Commentary:
	 ;; Customized startup for Emacs
	 ;;
	 ;;; Code:

	 ;; Eternally grateful to have gleaned lessons from:
	 ;;   http://pages.sachachua.com/.emacs.d/Sacha.html
	 ;;   https://github.com/purcell/emacs.d
	 ;;   https://github.com/howardabrams/dot-files
	 ;;   https://github.com/skeeto/.emacs.d
   #+end_src


** Setup Load Paths
   Emacs only includes packages under the =user-emacs-directory= (default =~/.emacs.d/elpa/=), so if we want to load anything
   else up we'll need to tell Emacs where to look. I've adopted something I've seen out and about, here and there,
   floating around the internet.

   #+begin_src emacs-lisp
	 (add-to-list 'load-path "~/.emacs.d/elisp/")
   #+end_src

   Load my machine local custom libraries directly, if they exist. Elfeed is only machine local because I've been lazy
   in sharing it, and also I only pay attention to work related feeds on my work machine.
   #+begin_src emacs-lisp
	 (if (file-readable-p "~/.emacs.d/elisp/elfeed-conf.el")
		 (load-library "elfeed-conf"))
   #+end_src


** Kill Dir-Locals
   Since I don't use directory local variables for Emacs very much if at all, and considering they could load arbitrary
   emacs-lisp, potentially without my knowing, lets prevent that from happening.

   #+begin_src emacs-lisp
	 (setq enable-local-eval nil
		   enable-local-variables nil)
   #+end_src


** Encoding Systems
   Pretty much just set the coding system to UTF-8. Also enable the Japanese language environment to support study.

   #+begin_src emacs-lisp
	 (prefer-coding-system 'utf-8)
	 (set-keyboard-coding-system 'utf-8)
	 (set-terminal-coding-system 'utf-8)
	 (set-selection-coding-system 'utf-8)
	 (set-default-coding-systems 'utf-8)

	 (set-language-environment "japanese")
   #+end_src


*** TODO Identify Need and Refactor
	I wonder if I need to set all of these individually, or if I could just get by with default or something else?


** Emacs Appearance
*** Kill Unnecessary Default Clutter
	Give me back my screen real estate. I don't need your newfangled and fancy GUI features, they just get in the way of
	more lines of sweet, sweet text.

	#+begin_src emacs-lisp
	  (setq inhibit-startup-screen t
			inhibit-startup-message t
			initial-scratch-message nil)

	  (tool-bar-mode -1)
	  (menu-bar-mode -1)
	  (scroll-bar-mode -1)
	#+end_src


*** Style Our Frame
	Let's give Emacs a name, I think Emacs sounds nice.
	#+begin_src emacs-lisp
	  (setq frame-title-format "Emacs")
	#+end_src

	Let's make sure our buffers have unique names. If we were to open a file of the same name, but a different location
	we only need them to be a little unique, not full file path or even relative file path unique.
	#+begin_src emacs-lisp
	  (require 'uniquify)
	#+end_src

	Let's get some more screen real estate by using a small, code friendly font.
	#+begin_src emacs-lisp
	  (set-frame-font "monospace-10")
    #+end_src

	Let's keep track of time in the mode-line.
	#+begin_src emacs-lisp
	  (display-time-mode 1)
	#+end_src

	Let's add some transparency to make things look really slick.
	#+begin_src emacs-lisp
	  (set-frame-parameter (selected-frame) 'alpha '(92 . 90))
	  (add-to-list 'default-frame-alist '(alpha . (92 . 90)))
	#+end_src

	Display which-function-mode, and do so in the header line instead of mode line.

	#+begin_src emacs-lisp
	  (which-function-mode)
	  (defvar which-func-header-line-format)

	  (setq mode-line-misc-info (delete (assoc 'which-func-mode
						   mode-line-misc-info) mode-line-misc-info)
			which-func-header-line-format '(which-func-mode ("" which-func-format)))

	  (defadvice which-func-ff-hook (after header-line activate)
		"Hook for which-func formatting."
		(when which-func-mode
		  (setq mode-line-misc-info (delete (assoc 'which-func-mode
							   mode-line-misc-info) mode-line-misc-info)
			header-line-format which-func-header-line-format)))
	#+end_src


*** Improve Navigation Experience
	Let's keep track of the currently focused line, always, everywhere.
	#+begin_src emacs-lisp
	  (global-hl-line-mode t)
	#+end_src

	Let's make it easy to see current block parentheses, given they're both on screen.
	#+begin_src emacs-lisp
	  (show-paren-mode 1)
	#+end_src


*** Hunt Trailing White-space, Sometimes
	I personally disdain trailing white-space, but also dislike how visually congested =whitespace-mode= can be
	sometimes. As such, lets make things toggle-able so I can inspect white-space on demand with only a key chord. Also,
	lets give ourselves a nuclear option for stripping trailing white-space.

	#+begin_src emacs-lisp
	  (defun TT/toggle-trailing-whitespace ()
		"Toggle 'show-trailing-whitespace' between t and nil."
		(interactive)
		(setq show-trailing-whitespace (not show-trailing-whitespace)))

	  (global-set-key (kbd "C-c w m") 'whitespace-mode)
	  (global-set-key (kbd "C-c w t") 'TT/toggle-trailing-whitespace)
	  (global-set-key (kbd "<f5>") 'delete-trailing-whitespace)
	#+end_src


** Various Emacs Settings
   Enable quick Y/N prompts.
   #+begin_src emacs-lisp
	 (fset 'yes-or-no-p 'y-or-n-p)
   #+end_src

   Get rid of that annoying bell.
   #+begin_src emacs-lisp
	 (setq ring-bell-function 'ignore)
   #+end_src

   Enable final newline in all files. It's pretty common in software projects, and it's just a habit by now, I'll
   include it everywhere until I find somewhere that bites me because of it.
   #+begin_src emacs-lisp
	 (setq require-final-newline t)
   #+end_src

   At one point I had some slowness with cursor movement and scrolling. I forget why at this point, but I stumbled upon
   some answer that said disable this, and I've never looked back since.
   #+begin_src emacs-lisp
	 (setq auto-window-vscroll nil)
   #+end_src

   This probably deserves it's own section and some more configuration, but for now here's a minimal GPG setup.
   #+begin_src emacs-lisp
	 (defvar epg-gpg-program "gpg2")

	 ;; Auth
	 (defvar auth-sources '((:source "~/.emacs.d/secrets/.authinfo.gpg")) "Auth info source location.")
   #+end_src

*** Manage File Backups and Auto Save
	Emacs can get a bit aggressive with file backups and auto-saves. I particularly dislike how it can pollute my
	directories and especially collaborative projects with tilde files (e.g: =myfile.txt~=). Usually things like
	=.gitignore= are sufficient to insulate others from these, but I'd prefer not to see them myself.

	#+begin_src emacs-lisp
	  ;; File Backup Management
	  (setq backup-by-copying t
			backup-directory-alist `(("." . "~/saves"))
			delete-old-versions t
			kept-new-versions 6
			kept-old-versions 2
			version-control t)

	  ;; Autosave File Management
	  (setq auto-save-file-name-transforms
			`((".*" ,temporary-file-directory t)))
	#+end_src


*** Offload Custom File
	I don't want Emacs customize managed settings ending up in my init files, so lets give them their own nice little
	home. Every now and again I should go through and convert much of whatever is there into my literate configuration.

	#+begin_src emacs-lisp
	  (setq custom-file "~/.emacs.d/custom.el")
	  (when (file-exists-p custom-file)
		(load custom-file 'noerror))
	#+end_src


** Easy Config Editing
   Let's make it a only take a key-chord to pull up my literate configuration.

   #+begin_src emacs-lisp
	 (defun TT/locate-literate-config ()
	   "Locate and load my literate configuration file."
	   (interactive)
	   (find-file "~/.emacs.d/configuration.org"))

	 (global-set-key (kbd "C-c I") 'TT/locate-literate-config)
   #+end_src


** Key Frequency Tracking
   This helps identify frequently used commands which could be bound for faster use.

   #+begin_src emacs-lisp
	 (use-package keyfreq
	   :config
	   (keyfreq-mode 1)
	   (keyfreq-autosave-mode 1))
   #+end_src


* Emacs Interactions
  This section contains customizations which focus on Emacs navigation and interaction.

** Auto Revert Buffers
   In the event something has changed on the system, I want to pull in the updated files. =Magit= has been good about
   doing this for version controlled files, however I've often noticed some buffer diffs for other files. Time to change
   that.

   #+begin_src emacs-lisp
	 (use-package autorevert
	   :ensure nil
	   :diminish
	   :init (global-auto-revert-mode))
   #+end_src


** Multiple Cursors
   This package lets me spin up multiple cursors across lines or matching patterns which can lead to some pretty
   impressive editing and refactoring feats.

   #+begin_src emacs-lisp
	 (use-package multiple-cursors
	   :ensure t
	   :bind (;; Note that recomended 'C->' and 'C-<' are not characters in the shell.
			  ;; Thus I use their lowercase alternatives
			  ("C-c ."   . mc/mark-next-like-this)
			  ("C-c ,"   . mc/mark-previous-like-this)
			  ("C-c /"   . mc/mark-all-like-this)
			  ("C-c m m" . mc/mark-all-like-this-dwim)
			  ("C-c m a" . mc/edit-beginnings-of-lines)
			  ("C-c m e" . mc/edit-ends-of-lines)
			  ("C-c m s" . mc/mark-sgml-tag-pair)
			  ("C-c m l" . mc/edit-lines)))
   #+end_src



** =Helm=
   =Helm= gives us incremental completions and narrowing capabilities that really help find what you're looking for within
   Emacs.

   #+begin_src emacs-lisp
	 (use-package helm
	   :diminish helm-mode
	   :init (progn
			   (require 'helm-config)
			   (helm-mode))
	   :bind (("C-c h"   . helm-command-prefix)
			  ("M-x"     . helm-M-x)
			  ("M-y"     . helm-show-kill-ring)
			  ("C-x b"   . helm-mini)
			  ("C-c h a" . helm-apropos)
			  ("C-c h f" . helm-find-files)
			  ("C-c h o" . helm-occur)
			  ("C-c h m" . helm-man-woman))
	   :config
	   (require 'helm-command)
	   (require 'helm-for-files)
	   (require 'helm-imenu)
	   (require 'helm-semantic)
	   (require 'helm-misc)
	   (setq helm-split-window-inside-p      t
			 helm-M-x-fuzzy-match            t
			 helm-buffers-fuzzy-matching     t
			 helm-recentf-fuzzy-match        t
			 helm-semantic-fuzzy-match       t
			 helm-imenu-fuzzy-match          t
			 helm-apropos-fuzzy-match        t
			 helm-candidate-number-limit   100
			 helm-autoresize-max-height     20
			 helm-autoresize-min-height      0)
	   (add-to-list 'helm-sources-using-default-as-input 'heml-source-man-pages)
	   (helm-autoresize-mode t))
   #+end_src


** Buffer Folding with =Origami=
   =Origami= minor-mode enables text folding across Emacs. It's pretty useful, though sometimes slow and sometimes
   buggy. With =origami-reset= you can always unfold everything and reset the file, which has always been enough to
   ignore some of the hiccups.

   #+begin_src emacs-lisp
	 (use-package origami
	   :bind (("C-<tab>" . origami-recursively-toggle-node)
			  ("C-c u"   . origami-open-all-nodes)
			  ("C-c f"   . origami-close-all-nodes)
			  ("C-c n"   . origami-show-only-node)
			  ("C-c r"   . origami-reset))
	   :config
	   (global-origami-mode t))

   #+end_src


** Text Expansion with =Abbrev=
   =Abbrev= triggers expansion on pressing the space bar after your word, which is incredibly useful for stream of
   conscious text expansion. I use this mainly to expand acronyms and abbreviations, so I can be lazy typing but still
   create readable text for those not yet familiar with those short-strings. However, this is also extremely useful for
   creating shortcuts for words I type often.

   #+begin_src emacs-lisp
	 (use-package abbrev
	   :ensure nil
	   :diminish abbrev-mode
	   :config
	   (setq abbrev-file-name
			 "~/.emacs.d/abbrev_defs")
	   (setq save-abbrevs t)
	   (if (file-exists-p abbrev-file-name)
		   (quietly-read-abbrev-file)))

	 ;; Add Abbrev-Mode Hooks
	 (dolist (hook '(erc-mode-hook
			 emacs-lisp-mode-hook
			 text-mode-hook
			 org-mode-hook))
	   (add-hook hook (lambda () (abbrev-mode 1))))
	 ;; (setq default-abbrev-mode t) ;; Or, default on everywhere
   #+end_src


** Templating with =Yasnippet=
   Both for programming and regular editing I have a bunch of snippets for text expansion. It doesn't always seem
   suitable for me to use =abbrev=, especially for large templates, but that's more of a personal choice than a "can it
   be done" thing.

   So, for anything more than abbreviation expansion or word shortcut expansions I use =yasnippet= to tab expand and
   interactively fill out templates.

   #+begin_src emacs-lisp
	 (use-package yasnippet
	   :diminish yas-minor-mode
	   :diminish yas-global-mode
	   :bind (("C-c y r" . yas-reload-all)
			  ("C-c y n" . yas-new-snippet)
			  ("C-c y x" . yas-exit-snippet)
			  ("C-c y d" . yas-describe-tables)
			  ("C-c y v" . yas-visit-snippet-file)
			  ("C-c y l" . yas-load-snippet-buffer-and-close))
	   :config
	   (setq yas-verbosity 1)
	   (yas-global-mode 1))
   #+end_src


** Internet Relay Chat with =ERC=
   Emacs comes with it's own Internet Relay Chat client, =ERC=. I use this to chat over IRC from right within Emacs.

   #+begin_src emacs-lisp
	 (use-package erc
	   :defer t
	   :config
	   (setq erc-nick "paraparity"
			 erc-hide-list '("PART" "QUIT" "JOIN" "NICK")
			 erc-server "irc.freenode.net"
			 erc-kill-buffer-on-part t
			 erc-scrolltobottom-mode t
			 erc-autojoin-channels-alist '(("freenode.net" "##programming" "#org-mode"))))
   #+end_src


** TODO Remote Interactions with =Tramp=
   Emacs comes packaged with a really cool utility I'm desperately under-utilizing. More work to be done here still.

   Let's change where Tramp saves things, and use SSH as our default method.

   #+begin_src emacs-lisp
	 (use-package tramp)

	 (set-default 'tramp-auto-save-directory "~/.saves/tramp/")
	 (setq tramp-default-method "ssh")

	 ; TODO: if windows: use PuTTy Plink; if *nix: use ssh
   #+end_src


* =Org-Mode= Configuration
  =org-mode= is probably my biggest anchor to Emacs. I've tried org-like plugins for other editors and IDEs, but nothing
  compares to the real thing.

  Let's load all the things! Well, all the things I use anyway.

  #+begin_src emacs-lisp
	(use-package org)
	(use-package ob-C :ensure nil)
	(use-package ob-ditaa :ensure nil)
	(use-package ob-dot :ensure nil)
	(use-package ob-js :ensure nil)
	(use-package ob-perl :ensure nil)
	(use-package ob-plantuml :ensure nil)
	(use-package ob-sql-mode)
	(use-package org-agenda :ensure nil)
	(use-package org-capture :ensure nil)
	(use-package org-clock :ensure nil)
	(use-package ox :ensure nil)
	(use-package ox-ascii :ensure nil)
	(use-package ox-asciidoc)
	(use-package ox-html :ensure nil)
	(use-package ox-latex :ensure nil)
	(use-package ox-pandoc)
	(use-package ox-slimhtml)

	;; This wasn't loading well via use-package...
	(require 'org-tempo)

	(setq org-modules
		  '((org-bbdb org-bibtex org-docview org-eww org-gnus org-habit org-info org-irc org-mhe org-rmail org-tempo org-w3m)))

	(add-hook 'org-mode-hook 'turn-on-auto-fill)
	(add-hook 'org-mode-hook
			  '(lambda () (origami-mode nil)))

	(setq org-src-fontify-natively t
		  org-src-tab-acts-natively t)
  #+end_src

** Org Structure
   This section sets up my org-mode file structure. This involves the root of my org directory, the location of my
   agenda files, and the like.

   #+begin_src emacs-lisp
	 (defvar org-directory           "~/org"                                         "Root 'org-mode' directory.")
	 (defvar TT/org-agenda-dir       (concat org-directory "/agendas")               "Top level org directory for Getting Things Done (GTD) organizer files.")
	 (defvar TT/org-calendar         (concat TT/org-agenda-dir "/calendar.org")      "Calendar for scheduled actionables.")
	 (defvar TT/org-habits           (concat TT/org-agenda-dir "/habits.org")        "Habits for periodic todos.")
	 (defvar TT/org-inbox            (concat TT/org-agenda-dir "/inbox.org")         "The collection bin for everything to be refiled.")
	 (defvar TT/org-incubate-dir     (concat TT/org-agenda-dir "/incubate")          "Categories of inactionable things to incubate.")
	 (defvar TT/org-ideas            (concat TT/org-incubate-dir "/ideas.org")       "Someday agenda to capture general or 'idea?' ideas.")
	 (defvar TT/org-projects         (concat TT/org-incubate-dir "/projects.org")    "Someday agenda for project ideas.")
	 (defvar TT/org-travel           (concat TT/org-incubate-dir "/travel.org")      "Someday agenda for travel related things.")
	 (defvar TT/org-someday          (concat TT/org-incubate-dir "/someday.org")     "Someday agenda for things I may want to revisit.")
	 (defvar TT/org-emacs-maybe      (concat TT/org-incubate-dir "/emacs-maybe.org") "Someday agenda for Emacs related things.")
	 (defvar TT/org-learning-dir     (concat TT/org-agenda-dir "/learning")          "Agendas for structured learning.")
	 (defvar TT/org-management       (concat TT/org-learning-dir "management.org")   "Learning for engineering management.")
	 (defvar TT/org-development      (concat TT/org-learning-dir "development.org")  "Learning for software development.")
	 (defvar TT/org-manager          (concat TT/org-agenda-dir "/manager.org")       "Actionables and captures for 1:1s with my manager.")
	 (defvar TT/org-organizer        (concat TT/org-agenda-dir "/organizer.org")     "Core organizer tracking prioritized actionable work.")
	 (defvar TT/org-retrospective    (concat TT/org-agenda-dir "/retro.org")         "Capture target for retro related info or actionables.")
	 (defvar TT/org-review           (concat TT/org-agenda-dir "/review.org")        "Reference on and journal for reflection.")
	 (defvar TT/org-tickler          (concat TT/org-agenda-dir "/tickler.org")       "Time relevant reminders for 'decide to do later' items.")
	 (defvar TT/org-team-dir         (concat TT/org-agenda-dir "/teams")             "Directory for team specific organizers.")
	 (defvar TT/org-waiting          (concat TT/org-agenda-dir "/waiting.org")       "Delegated or blocked items awaiting external action.")
	 (defvar TT/org-blog             (concat org-directory "/blog")                  "Top level org directory for blog posts.")
	 (defvar TT/org-brain-dir        (concat org-directory "/brain")                 "Top level org directory for 'org-brain' reference material.")
	 (defvar TT/org-checklist-dir    (concat org-directory "/checklists")            "Top level org directory for action oriented reference; do/certify.")
	 (defvar TT/org-commonplace-dir  (concat org-directory "/commonplace")           "Top level org directory for 'commonplace book' material.")
	 (defvar TT/org-eng-notebook-dir (concat org-directory "/engineering-notebook")  "Top level org directory for engineering notebook entries.")
	 (defvar TT/org-journal-dir      (concat org-directory "/journal")               "Top level org directory for journal entries.")
	 (defvar TT/org-ledger-dir       (concat org-directory "/ledger")                "Top level org directory for accounting/budgeting ledgers.")
	 (defvar TT/org-glacier-dir      (concat org-directory "/glacier")               "Top level org directory for long term archival outside organizer.")

	 (defvar org-default-notes-file TT/org-inbox)
   #+end_src


** Org Linking
   Org-mode supports creating links to various resources across org-mode files and materials online.

   Let's create some short links for things I might reference often.

   #+begin_src emacs-lisp
	 ;; Links - use like: cpan:HTML or rfc-txt:7522
	 (setq org-link-abbrev-alist
		   '(("rfc-html" . "https://tools.ietf.org/html/rfc%s")
			 ("rfc-txt"  . "https://tools.ietf.org/rfc/rfc%s.txt")
			 ("rfc-pdf"  . "https://tools.ietf.org/pdf/rfc%s.pdf")
			 ("fhir-r4"  . "https://www.hl7.org/fhir/R4/%s")
			 ("us-core"  . "https://www.hl7.org/fhir/us/core/%s")
			 ("cpan"     . "https://metacpan.org/search?q=%s")
			 ("so"       . "https://stackoverflow.com/search?q=%s")
			 ("soq"      . "https://stackoverflow.com/questions/%s")
			 ("ese"      . "https://emacs.stackexchange.com/search?q=%s")
			 ("eseq"     . "https://emacs.stackexchange.com/questions/%s")))
   #+end_src


** Org To-Do

*** Keywords
	Org-mode has a set of configurable keywords, both sequenced and typed, which can be added to headlines and cycled
	through to track an arbitrary workflow you define. This is where I define my keywords.

	The default org-mode sequence is as follows:
	#+begin_example
	  ,-> (unmarked) -> TODO -> DONE --.
	  '--------------------------------'
	#+end_example

	However, that's pretty simple and I have something else in mind.

	#+begin_src emacs-lisp
	  (setq org-todo-keywords
			'((sequence "TODO(t)" "NEXT(n)" "DELEGATED(g@)" "STARTED(s)" "WAITING(w@)" "|" "DONE(d)" "DROP(x@)")
			  (sequence "REVIEW(r)" "|" "REVIEWED(v)")
			  (sequence "OPEN(o)"   "|" "CLOSED(c@)")))

	  (setq org-todo-keyword-faces
			'(("STARTED" . "cyan")
			  ("MAYBE"   . "purple")
			  ("WAITING" . (:foreground "yellow" :weight bold))
			  ("DROP"    . "DimGray")))
	#+end_src


*** Tags
	Org-mode files and headlines can be tagged to enable searching and correlating information across files and
	directories.

	To support my Emacs implementation of Getting Things Done (GTD), I have a set of tags I use to denote tasks,
	projects, and contexts. For now this is enough, though I think there's still more improvement to make here,
	especially when it comes to searching behavior.

	My tags come in three flavors:
	1. '@context' - indicates location, headspace, or tool these tasks are associated with, or some other context in
       which to act on them in
	2. 'TYPE' - indicates whether the item is a project or task, if it's next up, or if it has some other classification
	3. 'info' - represents informational tags for categorization and search

	#+begin_src emacs-lisp
	  (setq org-tag-alist
			'(("@career"         . ?c) ; personal professional development (different than learn?)
			  ("@coaching"       . ?C) ; peer professional development (work, 1:1s, feedback, stretch-opps)
			  ("@communication"  . ?m) ; messaging, email, outreach, inquiry, and publication work
			  ("@finances"       . ?f) ; banking, budgeting, investing, and most things money related
			  ("@firefights"     . ?F) ; incident response, unexpected/chaotic work, high-urgency (war-room, incident team, etc...)
			  ("@guild"          . ?g) ; involvement in communities of practice
			  ("@health"         . ?h) ; exercise, diet, point-of-care, etc...
			  ("@home"           . ?H) ; apartment related things
			  ("@learn"          . ?l) ; courses, intentional learning, study (different than career?)
			  ("@mentorship"     . ?M) ; peer professional development (non-work; volunteering)
			  ("@networking"     . ?n) ; professional relationship building and entrepreneurship
			  ("@office"         . ?o) ; general office tasks (un-bucketed)
			  ("@read"           . ?r) ; books and reading nook items
			  ("@review"         . ?R) ; periodic review - timed reminders (tickler)
			  ("@scheduling"     . ?d) ; calendar work, planning, conflict resolution
			  ("@sprint"         . ?s) ; sprint work (primarily development)
			  ("@travel"         . ?t) ; trip planning, packing, and similar
			  ("@workstation"    . ?w) ; home and office hardware, configs, etc...
			  ("IMPORTANT"       . ?I) ; something of significance or of great value
			  ("NEXT"            . ?N) ; the very next thing to be doing within a project
			  ("PROJECT"         . ?P) ; something that takes significant effort or time, and can be decomposed into individual tasks
			  ("TASK"            . ?T) ; an atomic actionable thing
			  ("URGENT"          . ?U) ; something that demands attention in a short timespan
			  ("administrative"  . ?a) ; administrative tasks, paperwork, check-boxes, overhead, etc...
			  ("hiring"          . ?i) ; talent acquisition: outreach, correspondence, and interviewing
			  ("journal"         . ?j)))

	  (setq org-tags-exclude-from-inheritance '("PROJECT")
			org-stuck-projects '("+PROJECT/-WAITING-DONE"
								 ("TODO" "STARTED") ()))
	#+end_src


** Org Agenda
   With org-mode to-do items and tags configured, we can start unleashing the real power behind org-mode and configure
   our agendas.

   Org-mode agendas pull from a list of files which I have mostly tucked away under the =agendas= sub-directory within
   my =org-directory=. The structure of these files is mostly informed by the Getting Things Done framework.

   #+begin_src emacs-lisp
	 ;; Agenda Files:
	 (setq org-agenda-files
		   (delq nil
				 (mapcar (lambda (x) (and x (file-exists-p x) x))
						 `("~/org/agendas/calendar.org"
						   "~/org/agendas/habits.org"
						   "~/org/agendas/inbox.org"
						   "~/org/agendas/organizer.org"
						   "~/org/agendas/tickler.org"
						   "~/org/agendas/waiting.org"))))
   #+end_src

   Let's also modify some other agenda settings.

   #+begin_src emacs-lisp
	 (setq org-agenda-skip-deadline-if-done t
		   org-agenda-skip-scheduled-if-done t)
   #+end_src

*** Agenda Helpers
	This section contains some helpful functions for working with agenda items.

	A while back I stumbled across Aaron Bieber's blog which has some really helpful posts about Emacs. Particularly of
	interest here is this post: [[https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html][An Agenda for Life with org-mode]]. From it, I've lifted the following helpers.

	#+begin_src emacs-lisp
	  (defun air/org-skip-subtree-if-priority (priority)
		"Skip an agenda subtree if it has a priority of PRIORITY.

		  PRIORITY may be one of the characters ?A, ?B, or ?C."
		(let ((subtree-end (save-excursion (org-end-of-subtree t)))
			  (pri-value (* 1000 (- org-lowest-priority priority)))
			  (pri-current (org-get-priority (thing-at-point 'line t))))
		  (if (= pri-value pri-current)
			  subtree-end
			nil)))

	  (defun air/org-skip-subtree-if-habit ()
		"Skip an agenda entry if it has a STYLE property equal to \"habit\"."
		(let ((subtree-end (save-excursion (org-end-of-subtree t))))
		  (if (string= (org-entry-get nil "STYLE") "habit")
			  subtree-end
			nil)))
	#+end_src


*** Agenda Commands
	Agenda commands are the powerhouse behind org-mode and agendas. These allow you to query across your agenda files
	and surface reports of varying complexity. It's a great way to get exactly the thing you want, with only a few
	keystrokes.

	Agenda commands have the following form:
	#+begin_example
	  (setq org-agenda-custom-commands
			'(
			  ;; (1 key) (2 description (optional)) (3 type of search) (4 search term)
			  ("c" "Desk Work" tags-todo "computer"
			   ((org-agenda-files '("~/org/widgets.org" "~/org/clients.org")) ;; (5 settings (optional))
				(org-agenda-sorting-strategy '(priority-up effort-down)))
			   ("~/computer.html"))                                           ;; (6 export files (optional))
			  ;; ... other commands
			  ))
	#+end_example

	My agenda commands are below.

	#+begin_src emacs-lisp
	  (setq org-agenda-custom-commands
			'(("d" "Daily agenda and all TODOs"
			   ((tags "PRIORITY=\"A\""
					  ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
					   (org-agenda-overriding-header "High-Priority Unfinished Tasks:")))
				(agenda ""
						((org-agenda-span 1)))
				(alltodo ""
						 ((org-agenda-skip-function
						   '(or (air/org-skip-subtree-if-habit)
								(air/org-skip-subtree-if-priority ?A)
								(org-agenda-skip-if nil '(scheduled deadline))))
						  (org-agenda-overriding-header "All Normal Priority Tasks:"))))
			   ((org-agenda-compact-blocks t)))
			  ("1" "Q1" tags-todo "+IMPORTANT+URGENT")
			  ("2" "Q2" tags-todo "+IMPORTANT-URGENT")
			  ("3" "Q3" tags-todo "-IMPORTANT+URGENT")
			  ("4" "Q4" tags-todo "-IMPORTANT-URGENT")
			  ("D" "Daily Action List"
			   ((agenda ""
						((org-agenda-span 1)
						 (org-agenda-sorting-strategy
						  '((agenda time-up priority-down tag-up)))
						 (org-deadline-warning-ndays 0)))))
			  ("w" "Weekly Review"
			   ((agenda ""
						((org-agenda-span 7)))
				(stuck "")
				(tags "PROJECT")
				(todo "WAITING")))
			  ("y" "Someday Maybe"
			   ((todo "MAYBE"
					  ((org-agenda-files '("~/org/maybe.org"))))))
			  ("r" "Review"
			   ((todo "REVIEW"
					  ((org-agenda-files '("~/org/review.org"))))))
			  ("c" "Calendar"
			   ((agenda ""
						((org-agenda-span 7)
						 (org-agenda-start-on-weekday 0)
						 (org-agenda-time-grid-nil)
						 (org-agenda-repeating-timestamp-show-all t)
						 (org-agenda-entry-types '(:timestamp :sexp))))))
			  ("x" "With deadline columns"
			   ((alltodo ""
						 ((org-agenda-overriding-columns-format "%20ITEM %DEADLINE")
						  (org-agenda-view-columns-initially t)))))
			  ("X" "Upcoming Deadlines"
			   ((agenda ""
						((org-agenda-entry-types '(:deadline))
						 (org-agenda-span 1)
						 (org-deadline-warning-days 60)
						 (org-agenda-time-grid nil)))))
			  ("P" "Printed agenda"
			   ((agenda ""
						((org-agenda-span 7)
						 (org-agenda-start-on-weekday nil)
						 (org-agenda-repeating-timestamp-show-all t)
						 (org-agenda-entry-types '(:timestamp :sexp))))
				(agenda ""
						((org-agenda-span 1)
						 (org-deadline-warning-days 7)
						 (org-agenda-todo-keyword-format "[ ]")
						 (org-agenda-scheduled-leaders '("" ""))
						 (org-agenda-prefix-format "%t%s")))
				(todo "TODO"
					  ((org-agenda-prefix-format "[ ] %T: ")
					   (org-agenda-sorting-strategy '(tag-up prority-down))
					   (org-agenda-todo-keyword-format "")
					   (org-agenda-overriding-header "\nTasks by Context\n-----------------\n"))))
			   ((org-agenda-with-colors nil)
				(org-agenda-compact-blocks t)
				(org-agenda-remove-tags t)
				(ps-number-of-columns 2)
				(ps-landscape-mode t))
			   ("~/agenda.ps"))
			  ("Q" . "Custom Queries")
			  ("Qa" "Archive Search"
			   ((search ""
						((org-agenda-files
						  (file-expand-wildcards "~/org/archive/*.org"))))))
			  ("QA" "Archive Tags Search"
			   ((org-tags-view ""
							   ((org-agenda-files
								 (file-expand-wildcards "~/org/archive/*.org"))))))))
	#+end_src

**** TODO Incrementally Compose Commands for Better Literate Docs


** Org Clocking
   Org-mode gives us the ability to track time by clocking in and out of headlines. Combined with to-do items and
   agendas, we can really get some value out of this functionality.

   #+begin_src emacs-lisp
	 (setq org-clock-continuously t
		   org-clock-in-resume t
		   org-clock-into-drawer 1
		   org-clock-out-remove-zero-time-clocks t
		   org-clock-out-when-done t
		   org-clock-persist t
		   org-clock-report-include-clocking-task t
		   org-treat-insert-todo-heading-as-state-change t
		   org-expiry-inactive-timestamps t
		   org-log-done 'time
		   org-log-into-drawer "LOGBOOK"
		   org-clock-in-switch-to-state "STARTED")

	 ;; TODO: Move these somewhere more appropriate
	 (setq org-src-window-setup 'current-window)
	 (setq org-html-postamble nil)

	 (org-clock-persistence-insinuate); Resume clocking task when emacs is restarted
   #+end_src


** Org Journal
   Let's set up where my journal files are stored, and the format of the entries.

   #+begin_src emacs-lisp
	 (use-package org-journal
	   :init (setq org-journal-dir TT/org-journal-dir
				   org-journal-file-format "%Y%m%d"
				   org-journal-date-format "%e %b %Y (%A)")
	   :config (setq org-journal-date-prefix "#+TITLE: Daily Note for "))
   #+end_src

*** Journal Helpers
	These are functions that will later enable us to interact with org-journal via capture templates, etc...

	#+begin_src emacs-lisp
	  (defun get-journal-file-yesterday ()
		"Gets filename for yesterday's journal entry."
		(let* ((yesterday (time-subtract (current-time) (days-to-time 1)))
			   (daily-name (format-time-string "%Y%m%d" yesterday)))
		  (expand-file-name (concat org-journal-dir daily-name))))

	  (defun journal-file-yesterday ()
		"Create and load a file based on yesterday's date."
		(interactive)
		(find-file (get-journal-file-yesterday)))

	  (defun org-journal-find-location ()
		"Open today's journal.
		  Specify a non-nil prefix to inhibit inserting the heading"
		(org-journal-new-entry t)
		(goto-char (point-min)))
	#+end_src


** Capture Templates
   Capture templates allow us to quickly invoke a key-chord and select a template to capture some thought directly to a
   good home for it. Tasks to my organizer or inbox, new journal items to my journal, etc...

   I define these by creating a new list to which I define and append each template one-by-one so I can group them in my
   literate configuration to better describe each part. First we must set up this list.

   #+begin_src emacs-lisp
	 ;; Org Capture Configuration
	 (defvar org-capture-templates (list) '())

	 ;; The list needs to be initialized for setcdr to work later
	 (setq org-capture-templates
		   '(("i" "Inbox" entry  (file+olp TT/org-inbox "Capture" "Todos")
			 ,(concat "* TODO %?\n"
					  "/Entered on/ %U") :empty-lines 1)))
   #+end_src

*** Helper Functions
	Lets set up helpers. These are functions I'll use in my capture templates to extend the functionality of templates
	themselves. These help make decisions, generate names, and do anything else I could need.

	#+begin_src emacs-lisp
	  ;;; BEGIN Capture Helpers
	  (defun region-to-clocked-task (start end)
		"Copies the selected text, from START to END, to the currently clocked in `org-mode` task."
		(interactive "r")
		(org-capture-string (buffer-substring-no-properties-start end) "C"))
	  (global-set-key (kbd "C-<F1>") 'region-to-clocked-task)

	  (defun capture-incident-response-file (path)
		"Generate dated file at capture PATH using interactively provided description."
		(interactive)
		(let ((name (read-string "Alert Name: ")))
		  (expand-file-name
		   (format "%s_%s.org" (format-time-string "%Y%m%d") name)
		   path)))

	  (defun org-capture-inbox ()
		"Capture to inbox."
		(interactive)
		(call-interactively 'org-store-link)
		(org-capture nil "i"))
	  ;;; END Capture Helpers
	#+end_src


*** Sprint Work
	Here I define my first capture group for Sprint Work. All templates within capture some work associated directly with
	the current sprint I'm working in.

	#+begin_src emacs-lisp :tangle no
	  ;; Capture group for Sprint Work
	  (setcdr (last org-capture-templates)
			  '(("s" "Sprint Capture Group")
				("sd" "Development Task" entry (file+olp TT/org-organizer "Current Sprint" "Development")
				 "* TODO [#A] %? :TASK:\n")
				("sv" "Review Task" entry (file+olp TT/org-organizer "Current Sprint" "Review")
				 "* TODO [#A] %? :TASK:\n")
				("sr" "Research Task" entry (file+olp TT/org-organizer "Current Sprint" "Research")
				 "* TODO [#A] RESEARCH: %? :TASK:\n")
				("ss" "Spike Task" entry (file+olp TT/org-organizer "Current Sprint" "Research")
				 "* TODO [#A] SPIKE: %? :TASK:\n")
				("si" "Interrupt" entry (file+olp TT/org-organizer "Current Sprint" "Other"))
				("so" "Other Task" entry (file+olp TT/org-organizer "Current Sprint" "Other")
				 "* TODO [#A] %? :TASK:\n")))
	#+end_src


*** Retrospective Items
	This second capture group is for capturing information observations and information related to how the sprint is
	going. Capture in the moment, make sense through reflection, synthesize for retrospective and present to the
	team. That's the general idea.

	#+begin_src emacs-lisp
	  ;; Capture Group for Retrospective Items
	  (setcdr (last org-capture-templates)
			  '(("r" "Retrospective Capture Group")
				("rk" "Kudos" item (file+olp TT/org-retrospective "Capture" "Kudos")
				 "- %?" :empty-lines 1)
				("rg" "Goodness" item (file+olp TT/org-retrospective "Capture" "Goodness")
				 "- %?" :empty-lines 1)
				("rb" "Badness" item (file+olp TT/org-retrospective "Capture" "Badness")
				 "- %?" :empty-lines 1)
				("rz" "Kaizen" item (file+olp TT/org-retrospective "Capture" "Kaizen")
				 "- %?" :empty-lines 1)))
	#+end_src


*** Office Work Capture
	As I made the transition from engineering work to management I found myself overusing the "office" context I
	originally had for non-development in-office work. This capture group helps me better capture tasks I find myself
	regularly doing as a manager, and better categorizes things within sub-groups of the "office" context.

	#+begin_src emacs-lisp
	  ;; Capture Group for Office Work
	  (setcdr (last org-capture-templates)
			  '(("o" "Office Capture Group")
				("oa" "Administrative" entry (file+olp TT/org-organizer "Office" "Administrative")
				 "* TODO [#B] %? :TASK:\n")
				("oc" "Communications" entry (file+olp TT/org-organizer "Office" "Communications")
				 "* TODO [#B] %? :TASK:\n")
				("of" "Firefighting" entry (file+olp TT/org-organizer "Office" "Firefighting")
				 "* TODO [#A] %? :TASK:\n")
				("oh" "Hiring" entry (file+olp TT/org-organizer "Office" "Hiring")
				 "* TODO [#B] %? :TASK:\n")
				("os" "Scheduling" entry (file+olp TT/org-organizer "Office" "Scheduling")
				 "* TODO [#B] %? :TASK:\n")
				("ot" "Task" entry (file+olp TT/org-organizer "Office" "General")
				 "* TODO [#B] %? :TASK:\n")))
	#+end_src


*** General To Do Items
	This capture group is for non-sprint related tasks, which should each go to their proper group and have a default
	priority based on how I typically file similar tasks. These can easily be adjusted up or down via the agenda view, so
	it's perfectly fine for them to be inaccurate for the task, as long as they're typically correct.

	#+begin_src emacs-lisp
	  ;; Non-Sprint Todo Capture Group
	  (setcdr (last org-capture-templates)
			  '(("t" "General Todo Capture Group")
				("tc" "Career Task" entry (file+headline TT/org-organizer "Career")
				 "* TODO [#B] %? :TASK:\n")
				("tg" "Guild Task" entry (file+headline TT/org-organizer "Guild")
				 "* TODO [#C] %? :TASK:\n")
				("tw" "Workstation Task" entry (file+headline TT/org-organizer "Workstation")
				 "* TODO [#C] %? :TASK:\n")
				("tt" "General Task" entry (file+headline TT/org-organizer "Tasks")
				 "\n* TODO [#C] %? :TASK:\n %i\n %a\n\n")))
	#+end_src


*** Meetings
	This capture group is for meetings, habits, and other entries that should be tied to the calendar.

	#+begin_src emacs-lisp
	  ;; Capture Group for Meetings
	  (setcdr (last org-capture-templates)
			  '(("m" "Meeting Capture Group")
				("mm" "Pop Up Meetings and One-Offs" entry (file+olp TT/org-calendar "Meetings" "One Offs")
				 "* TODO %?\n")))
	#+end_src


*** Test Group
	#+begin_src emacs-lisp
	  ;; Test capture group - testing nested sub-groups
	  (setcdr (last org-capture-templates)
			  '(("q" "Test Capture Group")
				("qa" "Test Capture Sub-Group A")
				("qaa" "AA Template" entry (file+olp TT/org-inbox "Test" "A" "AA")
				 "* TODO [#A] %? :TASK:\n" :empty-lines 1)
				("qaa" "AB Template" entry (file+olp TT/org-inbox "Test" "A" "AB")
				 "* TODO [#B] %? :TASK:\n" :empty-lines 1)
				("qb" "Test Capture Sub-Group B")
				("qba" "BA Template" entry (file+olp TT/org-inbox "Test" "B" "BA")
				 "* TODO [#A] %? :TASK:\n" :empty-lines 1)
				("qbb" "BB Template" entry (file+olp TT/org-inbox "Test" "B" "BB")
				 "* TODO [#B] %? :TASK:\n" :empty-lines 1)))
	#+end_src


*** Miscellaneous
	The remaining capture templates are things that don't fit neatly into any one group.

	#+begin_src emacs-lisp
	  ;; Other Capture Templates (un-grouped)
	  (setcdr (last org-capture-templates)
			  '(("j" "Journal" entry (function org-journal-find-location)
				 "* %(format-time-string org-journal-time-format)%^{Title}\n%i%?")
				("n" "Note" entry (file+olp TT/org-inbox "Capture" "Notes")
				 "* %?\n:PROPERTIES:\n:CREATED:%U:END:\n\n%i\n\nFrom: %a" :empty-lines 1)
				("m" "Manager Notes" item (file+olp TT/org-manager "1:1 Prep" "Capture")
				 "- %?" :empty-lines 1)
				("x" "Incident Notes" entry (file (capture-incident-response-file "~/org/incidents"))
				 "* Incident Trigger\n%?\n\n* Five Whys\n\n* Action Items\n\n" :clock-in t)
				("X" "Item to Current Clock" item
				 (clock)
				 "%i%?" :empty-lines 1)
				("C" "Region to Current Clock" plain
				 (clock)
				 "%i" :immediate-finish t :empty-lines 1)))
	#+end_src


*** TODO Needs Work [0/1]
	- [ ] The =C-c c x= 'Incident Notes' capture template isn't working
	  #+begin_example
	  Invalid file location: nil
	  #+end_example


** Org Publish
   I can even use org-mode to publish static content!

   #+begin_src emacs-lisp
	 (setq org-publish-project-alist
		   '(("notes-content"
			  :base-directory "~/org/testnotes"
			  :base-extension "org"
			  :publishing-directory "~/public_html/"
			  :recursive t
			  :publishing-function org-html-publish-to-html
			  :headline-levels 4
			  :auto-preamble t)
			 ("notes-static"
			  :base-directory "~/org/testnotes"
			  :base-extensions "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf"
			  :publishing-directory "~/public_html" ; could be TRAMP path
			  :recursive t
			  :publishing-function org-publish-attachment)
			 ("notes" :components ("notes-content" "notes-static"))))

	 ;; TODO: https://github.com/fniessen/org-html-themes or other
   #+end_src


** Org Refile
   Despite having some nice capture templates, sometimes things still don't end up in the right place. That, or
   sometimes I just want to move something.

   #+begin_src emacs-lisp
	 (setq org-refile-targets '((org-agenda-files :maxlevel . 6)))
	 ;;(setq org-outline-path-complete-in-steps nil)
	 (setq org-refile-allow-creating-parent-nodes 'confirm)
   #+end_src


** Org-Babel

*** Supporting Tools
	Using org-babel, we can pull in some graphical helper tools to give it some rendering capabilities.

	#+begin_src emacs-lisp
	  (setq org-ditaa-jar-path "/usr/bin/ditaa.jar")
	  (setq org-plantuml-jar-path "/usr/share/plantuml/plantuml.jar")
	#+end_src


*** Displaying Inline Images
	Let's make it so org-babel can display images in org files directly.

	#+begin_src emacs-lisp
	  (defun bh/display-inline-images ()
		"Display inline images."
		(condition-case nil
			(org-display-inline-images)
		  (error nil)))

	  (add-hook 'org-babel-after-execute-hook 'bh/display-inline-images 'append)
	#+end_src


*** Configuring Supported Languages
	I'm only going to configure the subset of languages I use, but there are way more to choose from.

	#+begin_src emacs-lisp
	  (org-babel-do-load-languages
	   'org-babel-load-languages
	   '((C          . t)
		 (ditaa      . t)
		 (dot        . t)
		 (emacs-lisp . t)
		 (gnuplot    . t)
		 (js         . t)
		 (latex      . t)
		 (ledger     . t)
		 (org        . t)
		 (perl       . t)
		 (plantuml   . t)
		 (python     . t)
		 (shell      . t)
		 (sql        . t)))
	#+end_src


*** Final Things
	With =org-bable= mostly configured, lets plug it into some other stuff.

	#+begin_src emacs-lisp
	  (add-to-list 'org-src-lang-modes (quote ("plantuml" . fundamental)))
	#+end_src


** Org References
   - https://orgmode.org/manual/Template-elements.html
   - https://orgmode.org/manual/Template-expansion.html
   - https://orgmode.org/manual/Refile-and-Copy.html
   - https://orgmode.org/manual/Configuration.html Projects for publishing


* Development Interactions
  This section contains customizations for development and working within coding environments.

** Editor Config
   See [[https://editorconfig.org/][EditorConfig.org]] for more details. However, this helps me play nice across source repositories, and helps keep
   contributors happily using their own editor/IDE.

   #+begin_src emacs-lisp
	 (use-package editorconfig
	   :ensure t
	   :diminish editorconfig-mode
	   :config
	   (editorconfig-mode 1))
   #+end_src


** TODO Language Server
   The Language Server Protocol (LSP) sets up a contract for an editor (client) to chat with a language server to reduce
   development burden of supporting language interactions across languages and editors. Instead, the server can worry
   about supporting language interactions and any editor with a client can get the benefit of that abstraction.

   Emacs has both the [[https://github.com/emacs-lsp/lsp-mode][lsp-mode]] and [[https://github.com/joaotavora/eglot][eglot]] packages to support client interfaces with various language server
   backends. I've chosen to leverage =lsp-mode= as my language server client.

   #+begin_src emacs-lisp
	 ;; LSP mode configuration
	 (use-package lsp-mode
	   :commands lsp
	   :hook (c++-mode python-mode go-mode-hook)
	   :init
	   (setq lsp-prefer-flymake nil))

	 (use-package lsp-ui :commands lsp-ui-mode)
	 (use-package company-lsp :commands company-lsp)
   #+end_src


** On The Fly Checking
   Fly-Check enables on the fly syntax checking which helps me catch errors as I write them and prompts me to fix them
   immediately. This enforces a tight feedback loop in development.

   #+begin_src emacs-lisp
	 (use-package flycheck)

	 (add-hook 'after-init-hook #'global-flycheck-mode)

	 (setq flycheck-checkers
		   (quote (asciidoc
				   c/c++-cppcheck
				   css-csslint
				   emacs-lisp
				   emacs-lisp-checkdoc
				   handlebars
				   html-tidy
				   javascript-eslint
				   json-jsonlint
				   less
				   make
				   perl
				   perl-perlcritic
				   python-flak8
				   python-pylint
				   rust
				   sh-bash
				   sh-zsh
				   sh-spellcheck
				   tex-chktex
				   tex-lacheck
				   texinfo
				   xml-xmlstarlet
				   xml-xmllint
				   yaml-jayaml)))
	 ;; Others: cfenging chef-foodcritic coffee coffee-coffeelint d-dmd elixir
	 ;;         erlang eruby-erubis go-gofmt go-golint go-vet go-build go-test
	 ;;         haml haskell-ghc haskell-hlint lua php php-phpmd php-phpcs
	 ;;         puppet-parser puppet-lint racket rst rst-sphinx ruby-rubocop
	 ;;         ruby-rubylint ruby ruby-jruby sass scala scss slim verilog-verilator

	 (setq-default flycheck-disabled-checkers
				   '((javascript-jshint
					  javascript-jslint
					  javascript-gjslint
					  c/c++-clang)))

	 ;; Enable C++14 support for GCC
	 (add-hook 'c++-mode-hook (lambda () (setq flycheck-gcc-language-standard "c++14")))

	 ;; Use project relative eslint; see https://emacs.stackexchange.com/questions/21205
	 (defun TT/use-eslint-from-node-modules ()
	   "Use project local eslint node modules."
	   (let* ((root (locate-dominating-file
					 (or (buffer-file-name) default-directory)
					 "node_modules"))
			  (eslint (and root
						   (expand-file-name "node_modules/eslint/bin/eslint.js"
											 root))))
		 (when (and eslint (file-executable-p eslint))
		   (setq-local flycheck-javascript-eslint-executable eslint))))

	 (add-hook 'flycheck-mode-hook #'TT/use-eslint-from-node-modules)

	 ;; Enable flycheck globally:
	 (add-hook 'after-init-hook #'global-flycheck-mode)

	 ;; See: https://emacs.stackexchange.com/questions/13065
	 ;; (defun setup-flycheck-clang-project-path ()
	 ;;   "Use project local clang."
	 ;;   (let ((root (ignore-errors (projectile-project-root))))
	 ;; 	(when root
	 ;; 	  (add-to-list
	 ;; 	   (make-variable-buffer-local 'flycheck-clang-include-path)
	 ;; 	   root))))

	 ;; (add-hook 'c++-mode-hook 'setup-flycheck-clang-project-path)
   #+end_src


** Company Completions
   Company-mode, or complete any mode, is an extremely useful tool for text/code completion.

   #+begin_src emacs-lisp
	 (use-package company
	   :ensure t
	   :diminish
	   :bind (:map company-active-map
				   ("M-n" . nil)
				   ("M-p" . nil)
				   ("C-n" . company-select-next)
				   ("C-p" . company-select-previous))
	   :init (global-company-mode)
	   :config
	   (setq company-tooltip-align-annotations t
			 company-idle-delay nil
			 company-minimum-prefix-length 2
			 company-require-match nil
			 company-show-numbers t
			 company-tooltip-limit 20)
	   (with-eval-after-load 'company
		 (global-set-key (kbd "C-c SPC") 'company-complete)))
   #+end_src

   It also plugs into =lsp-mode= which I'll be setting up later.
   #+begin_src emacs-lisp
	 (use-package company-lsp
	   :after (company lsp-mode)
	   :commands company-lsp
	   :config
	   (push 'company-lsp company-backends))
   #+end_src


** Projectile Project Management
   Projectile allows for project interaction from within Emacs. Additionally, it can hook into other powerful search
   utilities to really kick up project navigation.

   #+begin_src emacs-lisp
	 (use-package projectile
	   :ensure t
	   :config
	   (setq projectile-completion-system 'helm)
	   (setq projectile-switch-project-action 'helm-projectile)
	   (setq projectile-enable-caching t)
	   (setq projectile-globally-ignored-directories
			 '(".git" "node_modules" "__pycache__" ".vs"))
	   (setq projectile-globally-ignored-file-suffixes
			 '("#" "~" ".swp" ".o" ".so" ".exe" ".dll" ".elc" ".pyc" ".jar"))
	   (setq projectile-globally-ignored-files
			 '("TAGS" "tags"))
	   (with-eval-after-load "projectile"
		 (projectile-mode)
		 (helm-projectile-on)))

	 (use-package helm-projectile)
   #+end_src


** TODO =Magit= and Version Control
   Magical Git interactions in Emacs.

   #+begin_src emacs-lisp
	 (setq vc-handled-backends (delq 'Git vc-handled-backends))

	 (use-package magit
	   :ensure t
	   :defer t
	   :bind ("C-x g" . magit-status))
   #+end_src


** TODO =Treemacs=


** Language Configurations

*** Mode Bindings by File Type
	Make sure certain files open in certain modes.

	#+begin_src emacs-lisp
	  (add-to-list 'auto-mode-alist '("\\.py$"          . python-mode))
	  (add-to-list 'auto-mode-alist '("\\.org$"         . org-mode))
	  (add-to-list 'auto-mode-alist '("\\.ts$"          . typescript-mode))
	  (add-to-list 'auto-mode-alist '("\\.css$"         . css-mode))
	  (add-to-list 'auto-mode-alist '("\\.md$"          . markdown-mode))
	  (add-to-list 'auto-mode-alist '("\\.markdown$"    . markdown-mode))
	  (add-to-list 'auto-mode-alist '("\\.hbs$"         . handlebars-mode))
	  (add-to-list 'auto-mode-alist '("\\.README\\.md$" . gfm-mode))
	  (add-to-list 'auto-mode-alist '("Jenkinsfile$"    . groovy-mode))
	#+end_src


*** Perl Customizations
	I used to write mostly in Perl for work, and =cperl-mode= was what my Emacs wielding colleagues used at my
	employer. It was definitely better than the Vanilla Emacs defaults.

	#+begin_src emacs-lisp
	  (use-package cperl-mode)

	  (defalias 'perl-mode 'cperl-mode)
	  (defvaralias 'c-basic-offset 'tab-width)
	  (defvaralias 'cperl-indent-level 'tab-width)

	  ;; Override perl-mode with cperl-mode
	  (mapc
	   (lambda (pair)
		 (if (eq (cdr pair) 'perl-mode)
			 (setcdr pair 'cperl-mode)))
	   (append auto-mode-alist interpreter-mode-alist))
	#+end_src


*** JavaScript
	From time to time I've developed either tangentially or immersively in JavaScript, both in the Web and in
	Node. =js2-mode= has been good to me for that. I tried =js3-mode=, but found it lacked features and had fallen out
	of support. I'm somewhat eyeing =indium=, but would likely prefer to just use a =lsp-mode= solution that also
	supports Typescript.

	#+begin_src emacs-lisp
	  (use-package js2-mode
		:defer t
		:mode "\\.js$"
		:config
		(require 'js2-refactor)
		(define-key js2-mode-map (kbd "M-.") nil)
		(add-hook 'js2-mode-hook #'js2-refactor-mode)
		(js2r-add-keybindings-with-prefix "C-c C-r")
		(define-key js2-mode-map (kbd "C-k") #'js2r-kill)
		(add-hook 'js2-mode-hook
				  (lambda ()
					(add-hook 'xref-backend-functions #'xref-js2-xref-backend nil t)))
		(add-hook 'js2-mode-hook
				  (lambda ()
					(setq mode-name "js2"))))
	#+end_src


*** TODO C/C++


* More Emacs Modes
** Ledger - Command Line Accounting
   Ledger, the command line double booking entry system. A geeky way to track your finances, with support in Emacs via
   =ledger-mode=!

   #+begin_src emacs-lisp
	 (use-package ledger-mode
	   :mode ("\\.ledger$")
	   :bind (:map ledger-mode-map
				   ("C-x C-s" . TT/ledger-save))
	   :preface
	   (defun TT/ledger-save ()
		 "Automatically clean the ledger buffer at each save."
		 (interactive)
		 (save-excursion
		   (when (buffer-modified-p)
			 (with-demoted-errors (ledger-mode-clean-buffer))
			 (save-buffer))))
	   :init
	   (setq ledger-post-amount-alignment-column 80))

	 (use-package flycheck-ledger
	   :after ledger-mode)
   #+end_src


* More Emacs Tools
** TODO PDF-Tools
   PDF-Tools enable PDF viewing within Emacs, so I don't have to have a second application open to read and take notes
   on PDF files. Just one more reason to never leave Emacs.

   Unfortunately my current configuration has trouble doing a fresh install as this has a dependency on =pdf-tools=
   being installed on the host running Emacs, which it may not be. On a system with this dependency installed we're up
   and running no problem though.

   #+begin_src emacs-lisp :tangle no
	 (use-package pdf-tools
	   :pin manual
	   :config
	   (setq-default pdf-view-display-size 'fit-page)
	   (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward))
   #+end_src


* TODO Helper Functions
  This section contains custom functions I'll sometimes invoke. These should probably live elsewhere, but for now, this
  is their home.

  #+begin_src emacs-lisp
	;; Regardless of which buffer you're in, jump to the active minibuffer
	(defun switch-to-minibuffer ()
	  "Switch to minibuffer window."
	  (interactive)
	  (if (active-minibuffer-window)
		  (select-window (active-minibuffer-window))
		(error "Minibuffer is not active")))

	(defun occur-non-ascii ()
	  "Find any non-ascii characters in the current buffer."
	  (interactive)
	  (occur "[[:nonascii:]]"))

	(defun open-config-file ()
	  "Open this file."
	  (interactive)
	  (find-file "~/.emacs.d/configuration.org"))
  #+end_src


* TODO Keybinding Overrides
  - Refactor to their relevant mode configurations. Only defaults or net new bindings should remain here.

  This section contains my keybinding overrides. After all the work we've done to get things set up or customized to my
  liking, I still need to sing to my own tune and play my own chords.

  #+begin_src emacs-lisp
	;; Buffer Key Bindings
	(global-set-key (kbd "S-w") 'kill-this-buffer)
	(global-set-key (kbd "C-S-<left>") 'shrink-window-horizontally)
	(global-set-key (kbd "C-S-<right>") 'enlarge-window-horizontally)
	(global-set-key (kbd "C-S-<down>") 'shrink-window)
	(global-set-key (kbd "C-S-<up>") 'enlarge-window)
	(global-set-key (kbd "C-x |") 'window-toggle-split-direction)
	(global-set-key (kbd "C-c o") 'switch-to-minibuffer)
	(global-set-key (kbd "<f8>") 'flyspell-buffer)
	(global-set-key (kbd "<f6>") 'speedbar)

	;; Org-Mode Keybindings
	(global-set-key (kbd "C-c a") 'org-agenda)
	(global-set-key (kbd "C-c c") 'org-capture)
	(global-set-key (kbd "C-c l") 'org-store-link)
	(global-set-key (kbd "C-c i") 'org-capture-inbox)


	;; Elfeed Keybindings
	(global-set-key (kbd "C-x w") 'elfeed)

	;; Misc Keybindings
	(global-set-key (kbd "C-c 1") 'open-config-file)
	(global-set-key (kbd "C-x #") 'comment-or-uncomment-region)
	(global-set-key (kbd "C-c d") 'duplicate-current-line-or-region)
	;;(global-set-key (kbd "M-.") 'find-tag-other-window)

	;; Modal Key Bindings
	(add-hook 'cperl-mode-hook
			  (lambda ()
				(local-set-key (kbd "C-h f") 'cperl-perldoc)))

	;; Kill the bane of my fat-fingers
	(global-unset-key (kbd "C-z"))
	(global-unset-key (kbd "C-x C-z"))
  #+end_src

** Enable Full Keyboard Number Pad
   Unfortunately I've found Emacs doesn't natively support full size keyboards, however this allows us to get our num-pad
   working.

   #+begin_src emacs-lisp
	 ;; Numpad Key Bindings
	 (global-set-key "\eOp" "0")
	 (global-set-key "\eOq" "1")
	 (global-set-key "\eOr" "2")
	 (global-set-key "\eOs" "3")
	 (global-set-key "\eOt" "4")
	 (global-set-key "\eOu" "5")
	 (global-set-key "\eOv" "6")
	 (global-set-key "\eOw" "7")
	 (global-set-key "\eOx" "8")
	 (global-set-key "\eOy" "9")
	 (global-set-key "\eOl" "+")
	 (global-set-key "\eOn" ".")
   #+end_src


* Final Countdown
  This section contains the last moment configurations that wrap up my personal customization and Emacs load. Here we'll
  kill mode-line clutter and start up the Emacs server.

  #+begin_src emacs-lisp
	;; Make it so I can recover old sessions after close or reboot
	(desktop-save-mode 1)

	;; Load configuration files local to employer
	;;(org-babel-load-file "~/.emacs.d/employer.org")

	;; Start the Emacs server
	(require 'server)
	(unless (server-running-p)
	  (defvar server-name (concat "server"(number-to-string (emacs-pid))))
	  (ignore-errors (server-start))

	  ;; Set the environment variables for *shell*.
	  (setenv "EDITOR" (concat "~/usr/local/bin/emacsclient -s " server-name)))

	;;(put 'narrow-to-region 'disabled nil)
  #+end_src


* Configuration Reading
  That's mostly it folks. Configuration is done, the rest are future works. This section collects other articles or
  configurations I've stumbled across and bookmarked for "eventual" reading.

** TODO List [0/39]
   - [ ] https://github.com/hungptit/tools and integration w/ Emacs
   - [ ] https://github.com/yjwen/org-reveal
   - [ ] https://github.com/fniessen/org-html-themes
   - [ ] =hydra=
   - [ ] =ivy=
   - [ ] =treemacs=
   - [ ] =lsp-mode=, =lsp-ui=, =company-lsp=, =dap-mode=
   - [ ] =org-journal=
   - [ ] =org-brain=
   - [ ] =bbdb=
   - [ ] =ox-slimhtml=
   - [ ] =realgud=
   - [ ] bookmarks
   - [ ] =epg=
   - [ ] semantic
   - [ ] tramp, docker-tramp
   - [ ] docker-tramp
   - [ ] =fzf= - fuzzy file finding
   - [ ] MacOS X / Linux config
   - [ ] exec-path-from-shell
   - [ ] REST client
   - [ ] org-mode blogging
   - [ ] markdown mode
   - [ ] straight.el (some kind of package management?)
   - [ ] https://gitlab.com/jaor/geiser
   - [ ] https://katherine.cox-buday.com/blog/2015/03/14/writing-specs-with-org-mode/
   - [ ] http://kitchingroup.cheme.cmu.edu/blog/category/org-mode/
   - [ ] https://ladicle.com/post/config/#screenshot
   - [ ] https://orgmode.org/worg/org-web.html
   - [ ] https://github.com/ianpan870102/.emacs.d
   - [ ] http://emacs.cafe/emacs/orgmode/gtd/2017/06/30/orgmode-gtd.html
   - [ ] https://joshrollinswrites.com/emacsorg/org-capture-template-1/
   - [ ] http://www.howardism.org/Technical/Emacs/getting-boxes-done.html
   - [ ] http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html
   - [ ] https://orgmode.org/worg/org-tutorials/org-latex-export.html
   - [ ] https://www.gnu.org/software/tramp/#Configuration
   - [ ] http://doc.norang.ca/org-mode.html
   - [ ] https://orgmode.org/worg/org-blog-articles.html
   - [ ] https://lispcookbook.github.io/cl-cookbook/emacs-ide.html
   - [ ] https://edwardtufte.github.io/tufte-css/
	 - https://edwardtufte.github.io/et-book/


