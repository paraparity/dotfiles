#+TITLE: Paraparity's Literate Emacs Configuration
#+PROPERTY: header-args :tangle yes
#+PROPERTY: ^:nil

* Overview
I've maintained my Emacs configuration in a number of styles across the years, each having its own strengths and
weaknesses. I've even declared configuration bankruptcy a few times. Presently I'm experimenting with a literate
configuration where I hope to better capture the intent and reasons for my configuration settings. My hope is that this
improves my experience maintaining my configuration, and that it also helps others understand what these configurations
do.

I invite your feedback openly. Welcome aboard my ship of Theseus.

** House Keeping

*** Variable Naming Convention
As is common among Emacsers, I've opted to adopt a naming scheme that identifies personal contributions and adds a bit
of individual flare. Considering the name I go by is =Paraparity=, you'll notice a number of names prefixed with
=TT/=. This represents a so-called =pair of T's= playing off of the =parity= portion of my handle.


*** Add Some Output Commentary
When tangled, all of these source blocks become an =.el= file. I'd still like that to be more friendly than just a bunch
of configuration code, so let's keep my old =init.el= header around.

#+begin_src emacs-lisp
;;; configuration.el --- Paraparity's Emacs configuration file
;;
;;; Commentary:
;; Customized startup for Emacs
;;
;;; Code:

;; Eternally grateful to have gleaned lessons from:
;;   http://doc.norang.ca/org-mode.html
;;   http://members.optusnet.com.au/~charles57/GTD/orgmode.html
;;   http://pages.sachachua.com/.emacs.d/Sacha.html
;;   https://www.labri.fr/perso/nrougier/GTD/index.html
;;   https://github.com/purcell/emacs.d
;;   https://github.com/howardabrams/dot-files
;;   https://github.com/skeeto/.emacs.d
#+end_src


* General Settings

** Security
I don't use directory local variables for Emacs very much if at all. Considering they could load arbitrary emacs-lisp,
potentially without my knowing, lets prevent that from happening.

#+begin_src emacs-lisp
(setopt enable-local-eval nil
        enable-local-variables nil)
#+end_src

*** GnuTLS
GnuTLS establishes encrypted SSL or TLS connections, and it can be used by Emacs. We want secure connections wherever we
can have them.

#+begin_src emacs-lisp
(use-package gnutls
  :demand t
  :if (gnutls-available-p)
  :custom
  (gnutls-verify-error t))

#+end_src


*** TODO GPG
Minimal GPG setup that could use some expansion.

Needs to first check =gpg= exists on the system and conditionally loads.

#+begin_src emacs-lisp
(use-package epg
  :demand t
  :custom
  (epg-pinentry-mode 'loopback))
#+end_src


*** TODO Auth Sources
#+begin_src emacs-lisp
(use-package auth-source
  :demand t
  :custom
  (auth-sources '("~/.emacs.d/secrets/.authinfo.gpg")))
#+end_src


** Where Files Live
Let's set up where to load configurations from, where to store saves, and give files homes.

*** Setup Load Paths
Emacs only includes packages under the =user-emacs-directory= (default =~/.emacs.d/elpa/=), so if we want to load
anything else up we'll need to tell Emacs where to look.

#+begin_src emacs-lisp
(add-to-list 'load-path "~/.emacs.d/elisp/")
#+end_src

**** TODO Improve machine local customization loading
Something could happen between checking and loading a file. Can I just attempt the load and handle an error if it
doesn't work?


*** Offload Custom File
I manage my custom literate configuration, but sometimes use Emacs easy configuration to tweak settings. Until I know I
want to keep these tweaks, I'll give them their own home.

#+begin_src emacs-lisp
(setopt custom-file "~/.emacs.d/custom.el")
(when (file-exists-p custom-file)
  (load custom-file 'noerror))
#+end_src


*** Separate File Backups and Auto Save
Emacs can get a bit aggressive with file backups and auto-saves. I dislike how it can pollute my directories and
especially collaborative projects with tilde files (e.g: =myfile.txt~=). Usually things like =.gitignore= are sufficient
to insulate others from these, but I'd prefer not to see them myself.

In some places I use directory backups which have a bad habit of replicating Emacs lock files, bloating the remote
location. I'd rather keep lock behavior while avoiding replication bloat, so I change the default lock file
location. Configuration courtesy of [[https://www.gnu.org/software/emacs/manual/html_node/elisp/File-Locks.html#index-lock_002dfile_002dname_002dtransforms][File Locks - lock-file-name-transforms]].

#+begin_src emacs-lisp
;; File Backup Management
(setopt backup-by-copying t
        backup-directory-alist `(("." . "~/saves"))
        delete-old-versions t
        kept-new-versions 6
        kept-old-versions 2
        version-control t)

;; Auto-save File Management
(setopt auto-save-file-name-transforms
        `((".*" ,temporary-file-directory t)))
#+end_src


*** Lock Files
I've never run into a situation where an Emacs lock file has helped me, and instead find them to be more like disk litter
than anything. Given I predominantly work on single-user environments that sync out to remote systems, let's kill this
until I need it.

#+begin_src emacs-lisp
(setq create-lockfiles nil)
#+end_src

This is my old config for lock files which I keep around in case I need to restore it. This section is not tangled.

#+begin_src emacs-lisp :tangle no
;; Lock File Management
(setopt lock-file-name-transforms
        '(("\\`/.*/\\([^/]+\\)\\'" "/var/tmp/\\1" t)))
#+end_src


*** Easy Config Editing
Let's make it a only take a key-chord to pull up my literate configuration.

#+begin_src emacs-lisp
(defun TT/locate-literate-config ()
  "Locate and load my literate configuration file."
  (interactive)
  (find-file "~/.emacs.d/configuration.org"))

(global-set-key (kbd "C-c I") 'TT/locate-literate-config)
#+end_src


*** Recent Files with =recentf=
#+begin_src emacs-lisp
(use-package recentf
  :bind ("C-x C-r" . recentf-open-files)
  :diminish recentf-mode
  :init
  (setopt recentf-exclude '("\\.gpg\\'"))
  (setopt recentf-auto-cleanup 'never)
  (recentf-mode t))
#+end_src


** Encoding Systems
Pretty much just set the coding system to UTF-8. Also enable the Japanese language environment to support study.

#+begin_src emacs-lisp
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)

(set-language-environment "japanese")
#+end_src


** Emacs Appearance
Who doesn't love customizing the look and feel of their workspace?

*** Remove Default Clutter
Give me back my screen real estate. I don't need your newfangled and fancy GUI features, they just get in the way of
more lines of sweet, sweet text. I also find the visual bell annoying, so let's take that out.

#+begin_src emacs-lisp
(setopt inhibit-startup-screen t
        inhibit-startup-message t
        initial-scratch-message nil)

(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)

(setq ring-bell-function 'ignore)
#+end_src


*** Manage Mode Line Modes with =diminish= and =delight=
=diminish= allows us to hide =mode-line= mode names and =delight= allows us to change their appearance using lisp. We
can use these to alias, hide, or even programmatically define =mode-line= mode indicators.

#+begin_src emacs-lisp
(use-package diminish)
(use-package delight)
#+end_src


*** Style Our Frame
Let's give Emacs a name, I think Emacs sounds nice.

#+begin_src emacs-lisp
(setq frame-title-format "Emacs")
#+end_src

Let's make sure our buffers have unique names. If we were to open a file of the same name, but a different location we
only need them to be a little unique, not full file path or even relative file path unique.

#+begin_src emacs-lisp
(use-package uniquify
  :ensure nil
  :custom
  (uniquify-buffer-name-style   'post-forward-angle-brackets)
  (uniquify-after-kill-buffer-p t))
#+end_src

Let's get some more screen real estate by using a small, code friendly font.

#+begin_src emacs-lisp
(set-frame-font "Fira Code-10")
#+end_src

Let's keep track of time in the mode-line.

#+begin_src emacs-lisp
(display-time-mode 1)
#+end_src

Let's also keep track of which column we're on in the buffer.

#+begin_src emacs-lisp
(setq column-number-mode t)
#+end_src

Let's add some transparency. Despite how powerful it is, I don't use Emacs for everything and this lets me read whatever
I have Emacs opened over. This can also let me see my desktop background which can be really cozy.

#+begin_src emacs-lisp
(set-frame-parameter (selected-frame) 'alpha '(92 . 90))
(add-to-list 'default-frame-alist '(alpha . (92 . 90)))
#+end_src


*** Hunt Trailing White-space, Sometimes
I personally disdain trailing white-space, but also dislike how visually congested =whitespace-mode= can be
sometimes. As such, lets make things toggle-able so I can inspect white-space on demand with only a key chord. Also,
lets give ourselves a nuclear option for stripping trailing white-space.

#+begin_src emacs-lisp
(defun TT/toggle-trailing-whitespace ()
  "Toggle 'show-trailing-whitespace' between t and nil."
  (interactive)
  (setq show-trailing-whitespace (not show-trailing-whitespace)))

(global-set-key (kbd "C-c w m") 'whitespace-mode)
(global-set-key (kbd "C-c w t") 'TT/toggle-trailing-whitespace)
(global-set-key (kbd "<f5>") 'delete-trailing-whitespace)

(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

Enable final newline in all files. It's pretty common in software projects, and it's just a habit by now, I'll include
it everywhere until I find somewhere that bites me because of it.

#+begin_src emacs-lisp
(setopt require-final-newline t)
#+end_src


*** Displaying Line Numbers
I used to use =linum-mode= globally, but it sometimes caused slowness and also wasn't really necessary outside of code
repositories. Now let's use the newer =display-line-numbers-mode= and set it to work in programming modes or be toggled
on demand.

#+begin_src emacs-lisp
(use-package display-line-numbers
  :hook (prog-mode . display-line-numbers-mode)
  :bind (:map global-map
              ("C-c T n" . display-line-numbers-mode)))
#+end_src


*** Ligatures with [[https://github.com/tonsky/FiraCode][FiraCode]]
I like the math symbol support from ligature friendly fonts like FiraCode. There are a few pre-requisites:
- FiraCode font is installed on your system
- Emacs was compiled with =Harfbuzz= and =Cairo= support
- There is a local copy of [[https://github.com/mickeynp/ligature.el][ligature.el]] to source from

When present Emacs can be configured to support it using the =ligature.el= package.

#+begin_src emacs-lisp
(use-package ligature
  :load-path "~/.emacs.d/elisp/"
  :config
  ;; Enable these ligatures in all major modes
  (ligature-set-ligatures 't '("www" "**" "***" "**/" "*>" "*/" "\\\\" "\\\\\\" "{-" "::"
                               ":::" ":=" "!!" "!=" "!==" "-}" "----" "-->" "->" "->>"
                               "-<" "-<<" "-~" "#{" "#[" "##" "###" "####" "#(" "#?" "#_"
                               "#_(" ".-" ".=" ".." "..<" "..." "?=" "??" ";;" "/*" "/**"
                               "/=" "/==" "/>" "//" "///" "&&" "||" "||=" "|=" "|>" "^=" "$>"
                               "++" "+++" "+>" "=:=" "==" "===" "==>" "=>" "=>>" "<="
                               "=<<" "=/=" ">-" ">=" ">=>" ">>" ">>-" ">>=" ">>>" "<*"
                               "<*>" "<|" "<|>" "<$" "<$>" "<!--" "<-" "<--" "<->" "<+"
                               "<+>" "<=" "<==" "<=>" "<=<" "<>" "<<" "<<-" "<<=" "<<<"
                               "<~" "<~~" "</" "</>" "~@" "~-" "~>" "~~" "~~>" "%%"))
  (global-ligature-mode 't))
#+end_src


** Various Emacs Settings
Enable quick Y/N prompts.

#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

I want to quickly get back to files I've recently been working in. Emacs can help with that using =recentf-mode=. We can
take this even further by using =save-place-mode= to remember cursor position in files too.

#+begin_src emacs-lisp
(save-place-mode 1)
#+end_src

At one point I had some slowness with cursor movement and scrolling. I forget why at this point, but I stumbled upon
some answer that said disable this, and I've never looked back since.

#+begin_src emacs-lisp
(setq auto-window-vscroll nil)
#+end_src

In general I use screens that aren't limited to 80 characters width. I'd prefer to take advantage of that width and have
a better default fill-column.

#+begin_src emacs-lisp
(setq-default fill-column 120)
#+end_src

I also find it useful in some languages and environments to have a hard tab stop list to get spacing right.

#+begin_src emacs-lisp
(setopt tab-stop-list
   '(4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96))
#+end_src

Most other applications I use replace selected text on input, and Emacs can be set to do the same.

#+begin_src emacs-lisp
(delete-selection-mode t)
#+end_src


** Key Frequency Tracking
This helps identify frequently used commands which could be bound for faster use.

#+begin_src emacs-lisp
(use-package keyfreq
  :config
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1))
#+end_src


* Emacs Interactions
This section contains customization for Emacs navigation and interaction.

** Improve Buffer Interactions
Let's keep track of the currently focused line, always, everywhere.

#+begin_src emacs-lisp
(global-hl-line-mode t)
#+end_src

Let's make it easy to see current block parentheses, given they're both on screen.

#+begin_src emacs-lisp
(show-paren-mode 1)
#+end_src

Let's display which-function-mode, and do so in the header line instead of mode line. This echoes the current org
heading or function to the topmost part of a buffer which helps me keep track of what context my cursor is in.

#+begin_src emacs-lisp
(which-function-mode)
(defvar which-func-header-line-format)

(setq mode-line-misc-info
      (delete
       (assoc 'which-func-mode
              mode-line-misc-info) mode-line-misc-info)
      which-func-header-line-format '(which-func-mode ("" which-func-format)))

(defadvice which-func-ff-hook (after header-line activate)
  "Hook for which-func formatting."
  (when which-func-mode
    (setq mode-line-misc-info
          (delete
           (assoc 'which-func-mode
                  mode-line-misc-info) mode-line-misc-info)
          header-line-format which-func-header-line-format)))
#+end_src


** Auto Revert Buffers
In the event something has changed on the system, I want to pull in the updated files. =magit= has been good about doing
this for version controlled files, however I've often noticed some buffer diffs for other files. =autorevert= should
help keep things in sync.

#+begin_src emacs-lisp
(use-package autorevert
   :ensure nil
   :diminish
   :init (global-auto-revert-mode))
#+end_src


** TODO Bookmarks
Configuration for bookmarking and returning to buffers.


** Multiple Cursors
Sometimes one cursor isn't enough. This package lets me spin up multiple cursors across lines or matching patterns which
can lead to some pretty impressive editing and refactoring feats.

#+begin_src emacs-lisp
(use-package multiple-cursors
  :bind (;; Note that recommended 'C->' and 'C-<' are not characters in the shell.
         ;; Thus I use their lowercase alternatives
         ("C-c ."   . mc/mark-next-like-this)
         ("C-c ,"   . mc/mark-previous-like-this)
         ("C-c /"   . mc/mark-all-like-this)
         ("C-c m m" . mc/mark-all-like-this-dwim)
         ("C-c m a" . mc/edit-beginnings-of-lines)
         ("C-c m e" . mc/edit-ends-of-lines)
         ("C-c m s" . mc/mark-sgml-tag-pair)
         ("C-c m l" . mc/edit-lines)))
#+end_src


** Incremental Narrowing with =helm=
=helm= gives us incremental completions and narrowing capabilities that really help find what you're looking for.

#+begin_src emacs-lisp
(use-package helm
  :diminish helm-mode
  :demand t
  :init (progn
          (helm-mode))
  :bind (("C-c h"   . helm-command-prefix)
         ("C-x b"   . helm-mini)
         ("C-c h a" . helm-apropos)
         ("C-c h b" . helm-buffers-list)
         ("C-c h f" . helm-find-files)
         ("C-c h i" . helm-info)
         ("C-c h o" . helm-occur)
         ("C-c h m" . helm-man-woman)
         ("C-c h s" . helm-swoop)
         ("C-c h y" . helm-yas-complete)
         :map global-map
         ("M-x"     . helm-M-x)
         ("M-y"     . helm-show-kill-ring)
         :map helm-map
         ("<tab>" . helm-execute-persistent-action)
         ("C-i" . helm-execute-persistent-action)
         ("C-z" . helm-select-action))
  :custom
  (helm-split-window-inside-p        t)
  (helm-move-to-line-cycle-in-source t)
  (helm-M-x-fuzzy-match              t)
  (helm-buffers-fuzzy-matching       t)
  (helm-recentf-fuzzy-match          t)
  (helm-semantic-fuzzy-match         t)
  (helm-imenu-fuzzy-match            t)
  (helm-apropos-fuzzy-match          t)
  (helm-candidate-number-limit       100)
  (helm-autoresize-max-height        20)
  (helm-autoresize-min-height        0)
  (helm-idle-delay                   0.01)
  (helm-input-idle-delay             0.01)
  (helm-quick-update                 t)
  :config
  (require 'helm-command)
  (require 'helm-for-files)
  (require 'helm-imenu)
  (require 'helm-semantic)
  (require 'helm-misc)
  (add-to-list 'helm-sources-using-default-as-input 'helm-source-man-pages)
  (helm-autoresize-mode t))
#+end_src

For a quick intro to =helm=, see: https://tuhdo.github.io/helm-intro.html


** Buffer Folding with =origami=
=origami= minor-mode enables text folding across Emacs. It's pretty useful, though sometimes slow and sometimes
buggy. With =origami-reset= you can always unfold everything and reset the file, which has always been enough to ignore
some of the hiccups.

I find this very helpful in collapsing functions in source code and narrowing my focus to the important parts of a file.

#+begin_src emacs-lisp
(use-package origami
  :diminish origami-mode
  :bind (("C-<tab>" . origami-recursively-toggle-node)
         ("C-c o u"   . origami-open-all-nodes)
         ("C-c o f"   . origami-close-all-nodes)
         ("C-c o n"   . origami-show-only-node)
         ("C-c o r"   . origami-reset))
  :config
  (global-origami-mode t))

#+end_src


** Text Expansion with =abbrev=
=abbrev= triggers expansion on pressing the space bar after your word, which is incredibly useful for stream of
conscious text expansion. I use this mainly to expand acronyms and abbreviations, so I can lazily type and still create
readable text for those not yet familiar with those short-strings. However, this is also extremely useful for creating
shortcuts for words I type often.

#+begin_src emacs-lisp
(use-package abbrev
  :ensure nil
  :diminish abbrev-mode
  :custom
  (abbrev-file-name "~/.emacs.d/abbrev_defs")
  (save-abbrevs t)
  :config
  (if (file-exists-p abbrev-file-name)
      (quietly-read-abbrev-file)))

;; Add Abbrev-Mode Hooks
(dolist (hook '(erc-mode-hook
                emacs-lisp-mode-hook
                text-mode-hook
                org-mode-hook))
  (add-hook hook (lambda () (abbrev-mode 1))))
;; (setq default-abbrev-mode t) ;; Or, default on everywhere
#+end_src


** Region Wrapping with =wrap-region=
#+begin_src emacs-lisp
(use-package wrap-region
  :diminish wrap-region-mode
  :config
  (wrap-region-global-mode t)
  (wrap-region-add-wrappers
   '(("(" ")")
     ("[" "]")
     ("{" "}")
     ("<" ">")
     ("'" "'")
     ("\"" "\"")
     ("‘" "’"   "q")
     ("“" "”"   "Q")
     ("*" "*"   "b" org-mode)
     ("*" "*"   "*" org-mode)
     ("/" "/"   "i" org-mode)
     ("/" "/"   "/" org-mode)
     ("~" "~"   "c" org-mode)
     ("~" "~"   "~" org-mode)
     ("=" "="   "v" org-mode)
     ("=" "="   "=" org-mode)
     ("_" "_"   "u" '(org-mode markdown-mode))
     ("**" "**" "b" markdown-mode)
     ("*" "*"   "i" markdown-mode)
     ("`" "`"   "c" '(markdown-mode ruby-mode))
     ("`" "'"   "c" lisp-mode))))
  #+end_src


** Templating with =yasnippet=
Both for programming and regular editing I have a bunch of snippets for text expansion. It doesn't always seem suitable
for me to use =abbrev=, especially for large templates, but that's more of a personal choice than a "can it be done"
thing.

So, for anything more than abbreviation expansion or word shortcut expansions I use =yasnippet= to tab expand and
interactively fill out templates.

#+begin_src emacs-lisp
(use-package yasnippet
  :diminish yas-minor-mode
  :diminish yas-global-mode
  :bind (("C-c y r" . yas-reload-all)
         ("C-c y n" . yas-new-snippet)
         ("C-c y x" . yas-exit-snippet)
         ("C-c y d" . yas-describe-tables)
         ("C-c y v" . yas-visit-snippet-file)
         ("C-c y l" . yas-load-snippet-buffer-and-close))
  :hook ((prog-mode . yas-minor-mode)
         (text-mode . yas-minor-mode))
  :custom
  (yas-verbosity 1)
  :config
  (yas-global-mode 1))
#+end_src


** Remote Interactions with =tramp=
Emacs comes packaged with a really cool utility I'm desperately under-utilizing.

Let's change where Tramp saves things, and use SSH as our default method.
#+begin_src emacs-lisp
(use-package tramp
  :custom
  (tramp-default-method "ssh")
  :config
  (set-default 'tramp-auto-save-directory "~/.saves/tramp/"))

;; TODO: if windows: use PuTTy PLINK; if *nix: use ssh
#+end_src

=helm-tramp= docs: https://github.com/masasam/emacs-helm-tramp

#+begin_src emacs-lisp
(use-package helm-tramp
  :after tramp
  :bind ("C-c t" . helm-tramp))

#+end_src

*** TODO =docker-tramp=
Either place under tramp or in development interactions section later.


** Screen Casting with =keykast=
Sometimes you want to share how something behaves in Emacs. For these scenarios, it's also really important to show a
peek behind the scenes. What keys or chords are you entering and what are they triggering? For this, there's
=keycast-mode= which you can enable/disable as needed with =M-x keycast-mode=.

#+begin_src emacs-lisp
(use-package keycast
  :pin melpa)
#+end_src


* =org-mode= Configuration
=org-mode= is probably my biggest anchor to Emacs. I've tried org-like plugins for other editors and IDEs, but nothing
compares to the real thing.

Let's load all the things! Well, all the things I use anyway.

#+begin_src emacs-lisp
(use-package org
  :pin gnu
  :mode ("\\.org$" . org-mode)
  :config (define-key org-mode-map (kbd "C-c C-r") verb-command-map))
(use-package ob-C :ensure nil)
(use-package ob-ditaa :ensure nil)
(use-package ob-dot :ensure nil)
(use-package ob-js :ensure nil)
(use-package ob-perl :ensure nil)
(use-package ob-plantuml :ensure nil)
(use-package ob-sql-mode)
(use-package org-agenda :ensure nil)
(use-package org-capture :ensure nil)
(use-package org-clock :ensure nil)
(use-package ox :ensure nil)
(use-package ox-ascii :ensure nil)
(use-package ox-asciidoc)
(use-package ox-confluence :ensure nil)
(use-package ox-html :ensure nil)
(use-package ox-latex :ensure nil)
(use-package ox-pandoc)

;; This wasn't loading well via use-package...
(require 'org-tempo)

(setopt org-modules
        '(ol-doi ol-bbdb ol-bibtex ol-docview ol-gnus ol-info ol-eww org-habit org-tempo))
#+end_src

Let's also update a few general settings and behavior.

#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'turn-on-auto-fill)
(add-hook 'org-mode-hook 'org-indent-mode)
(add-hook 'org-mode-hook
          #'(lambda () (origami-mode nil)))

(setopt org-src-fontify-natively t
        org-src-tab-acts-natively t
        org-src-preserve-indentation nil
        org-startup-indented t ; will this end my indentation woes?
        org-edit-src-content-indentation 0
        org-ellipsis " [+]")

(custom-set-faces '(org-ellipsis ((t (:foreground "gray40" :underline nil)))))
#+end_src

** Org Structure
This section sets up my org-mode file structure. This involves the root of my org directory, the location of my agenda
files, and the like.

#+begin_src emacs-lisp
(defvar org-directory            "~/org"                                         "Root \\='org-mode\\=' directory.")
(defvar TT/org-agenda-dir        (concat org-directory "/agendas")               "Top level org directory for Getting Things Done (GTD) organizer files.")
(defvar TT/org-calendar          (concat TT/org-agenda-dir "/calendar.org")      "Calendar for scheduled items.")
(defvar TT/org-habits            (concat TT/org-agenda-dir "/habits.org")        "Habits for periodic TODOs.")
(defvar TT/org-ideas             (concat TT/org-agenda-dir "/ideas.org")         "Idea capture and ideation.")
(defvar TT/org-inbox             (concat TT/org-agenda-dir "/inbox.org")         "The collection bin for everything to be refiled.")
(defvar TT/org-incubate-dir      (concat TT/org-agenda-dir "/incubate")          "Categories of in-actionable things to incubate.")
(defvar TT/org-emacs-maybe       (concat TT/org-incubate-dir "/emacs-maybe.org") "Someday agenda for Emacs related things.")
(defvar TT/org-maybe-projects    (concat TT/org-incubate-dir "/projects.org")    "Someday agenda for project ideas.")
(defvar TT/org-someday           (concat TT/org-incubate-dir "/someday.org")     "Someday agenda for things I may want to revisit.")
(defvar TT/org-travel            (concat TT/org-incubate-dir "/travel.org")      "Someday agenda for travel related things.")
(defvar TT/org-learning          (concat TT/org-agenda-dir "/learning.org")      "Agenda for structured learning.")
(defvar TT/org-organizer         (concat TT/org-agenda-dir "/organizer.org")     "Core organizer tracking prioritized actionable work.")
(defvar TT/org-people-dir        (concat TT/org-agenda-dir "/people")            "Org files specific to people.")
(defvar TT/org-projects          (concat TT/org-agenda-dir "/projects.org")      "")
(defvar TT/org-manager           (concat TT/org-people-dir "/manager.org")       "Actionable captures for 1:1s with my manager.")
(defvar TT/org-retrospective     (concat TT/org-agenda-dir "/retro.org")         "Capture target for retro related info or actionable items.")
(defvar TT/org-review            (concat TT/org-agenda-dir "/review.org")        "Reference on and journal for reflection.")
(defvar TT/org-tickler           (concat TT/org-agenda-dir "/tickler.org")       "Time relevant reminders for \\='decide to do later\\=' items.")
(defvar TT/org-waiting           (concat TT/org-agenda-dir "/waiting.org")       "Delegated or blocked items awaiting external action.")
(defvar TT/org-blog              (concat org-directory "/blog")                  "Top level org directory for blog posts.")
(defvar TT/org-brain-dir         (concat org-directory "/brain")                 "Top level org directory for \\='org-brain\\=' reference material.")
(defvar TT/org-checklist-dir     (concat org-directory "/checklists")            "Top level org directory for action oriented reference; do/certify.")
(defvar TT/org-commonplace-dir   (concat org-directory "/commonplace")           "Top level org directory for \\='commonplace book\\=' material.")
(defvar TT/org-journal-dir       (concat org-directory "/journal")               "Top level org directory for journal entries.")
(defvar TT/org-ledger-dir        (concat org-directory "/ledger")                "Top level org directory for accounting/budgeting ledgers.")
(defvar TT/org-projects-dir      (concat org-directory "/projects")              "Top level org directory for projects.")
(defvar TT/org-templates-dir     (concat org-directory "/templates")             "Top level org directory for templates.")
(defvar TT/org-cap-templates-dir (concat TT/org-templates-dir "/org-capture")    "Directory for \\='org-capture\\=' template files.")

(defvar org-default-notes-file TT/org-inbox)
#+end_src


** Org Roam

=org-roam= is a plaintext personal knowledge management (PKM) system. I'm starting to experiment with using it
vs. Obsidian.

#+begin_src emacs-lisp
(use-package org-roam
  :custom
  (org-roam-directory "~/org/brain/")
  (org-roam-completion-everywhere t)
  (org-roam-database-connector 'sqlite-builtin)
  :bind (("C-c n l" . org-roam-buffer-toggle)
         ("C-c n b" . org-roam-buffer-display-dedicated)
         ("C-c n a" . org-id-get-create)
         ("C-c n i" . org-roam-node-insert)
         ("C-c n f" . org-roam-node-find)
         ("C-c n c" . org-roam-capture)
         ("C-c n g" . org-roam-graph)
         ("C-c n z" . org-roam-alias-add)
         ("C-c n x" . org-roam-alias-remove)
         :map org-mode-map
         ("C-M-i"   . completion-at-point))
  :config
  (org-roam-db-autosync-mode)
  (org-roam-setup)
  (add-to-list 'display-buffer-alist
               '("\\*org-roam\\*"
                 (display-buffer-in-direction)
                 (direction . right)
                 (window-width . 0.33)
                 (window-height . fit-window-to-buffer))))
#+end_src

And maybe org-roam-ui for visualization.

#+begin_src emacs-lisp
(use-package websocket
  :after org-roam)

(use-package org-roam-ui
  :after org-roam
  :custom
  (org-roam-ui-sync-theme t)
  (org-roam-ui-follow t)
  (org-roam-ui-update-on-save t)
  (org-roam-ui-open-on-start nil))
#+end_src


** Org Agenda
With org-mode to-do items and tags configured, we can start unleashing the real power behind org-mode and configure our
agendas.

Org-mode agendas pull from a list of files which I have mostly tucked away under the =agendas= sub-directory within my
=org-directory=. The structure of these files is mostly informed by the Getting Things Done framework.

#+begin_src emacs-lisp
;; Agenda Files:
(setopt org-agenda-files
        (delq nil
              (mapcar (lambda (x) (and x (file-exists-p x) x))
                      `(,TT/org-calendar
                        ,TT/org-habits
                        ,TT/org-organizer
                        ,TT/org-projects
                        ,TT/org-tickler
                        ,TT/org-waiting))))
#+end_src

Let's also modify some other agenda settings.

#+begin_src emacs-lisp
(setopt org-agenda-skip-deadline-if-done t
        org-agenda-skip-scheduled-if-done t
        org-agenda-skip-scheduled-if-deadline-is-shown t
        org-agenda-skip-timestamp-if-done t
        org-agenda-skip-timestamp-if-deadline-is-shown t
        org-agenda-compact-blocks t
        org-agenda-show-future-repeats t
        org-agenda-dim-blocked-tasks nil ; dimming can slow the agenda  down - a filter could show blocked tasks better
        org-agenda-inhibit-startup t ; speedup agenda loading by ignoring startup options
        org-tags-column -120
        org-agenda-todo-keyword-format "%-12s"
        org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled
        org-agenda-time-grid
        '((daily today)
          (800 1000 1200 1400 1600 1800 2000)
          " ...... " "----------------"))
#+end_src


** Org To-Do
Org todos help keep track of work I plan to do and how I engaged with completing that work. Let's get a few general
things set up here.

#+begin_src emacs-lisp
(setopt org-treat-insert-todo-heading-as-state-change t)
#+end_src


*** To Do Keywords
Org-mode has a set of configurable keywords, both sequenced and typed, which can be added to headlines and cycled
through to track an arbitrary workflow you define. This is where I define my keywords.

The default org-mode sequence is as follows:
#+begin_example
,-> (unmarked) -> TODO -> DONE --.
'--------------------------------'
#+end_example

However, that's pretty simple and I have something else in mind.

#+begin_src emacs-lisp
(setopt org-todo-keywords
        '((sequence "TODO(t)" "STARTED(s!)"      "|" "DONE(d!)")
          (sequence "REVIEW(r!)" "REVIEWING(i!)" "|" "REVIEWED(v!)")
          (sequence "DELEGATED(g@!)"             "|" "COMPLETED(p!)")
          (sequence "MEET(m)" "MEETING(e!)"      "|" "MET(t!)")
          (sequence "APPOINTMENT(a)"             "|" "FINISHED(f!)")
          (sequence "|" "DROP(x@!)" "CANCELED(l!)")))

(setopt org-todo-keyword-faces
        '(("STARTED"  . "cyan")
          ("MEETING"  . "cyan")
          ("CANCELED" . "DimGray")
          ("DROP"     . "DimGray")))
#+end_src


*** Tags
Org-mode files and headlines can be tagged to enable searching and correlating information across files and directories.

To support my Emacs implementation of Getting Things Done (GTD), I have a set of tags I use to denote tasks, projects,
and contexts. For now this is enough, though I think there's still more improvement to make here, especially when it
comes to searching behavior.

My tags come in three flavors:
1. '@context' - indicates physical location, head-space, or tool these tasks are associated with, or some other
   context in which to act on them in
2. 'TYPE' - indicates whether the item is a project or task, if it's next up, or if it has some other classification
3. 'info' - represents informational tags for categorization and search

I try to give each tag a mnemonic hotkey and resolve collisions with capitalization or by choosing another key within
the word, but it's an imperfect system.

#+begin_src emacs-lisp
(setopt org-tag-alist
        '(("@administrative" . ?a) ; administrative tasks, paperwork, check-boxes, overhead, etc...
          ("@career"         . ?c) ; personal professional development (different than learn?)
          ("@communication"  . ?m) ; messaging, email, outreach, inquiry, and publication work
          ("@finances"       . ?f) ; banking, budgeting, investing, and most things money related
          ("@firefights"     . ?F) ; incident response, unexpected/chaotic work, high-urgency (war-room, incident team, etc...)
          ("@guild"          . ?g) ; involvement in communities of practice
          ("@health"         . ?h) ; exercise, diet, point-of-care, etc...
          ("@hiring"         . ?i) ; talent acquisition: outreach, correspondence, and interviewing
          ("@home"           . ?H) ; apartment related things
          ("@learn"          . ?l) ; courses, intentional learning, study (different than career?)
          ("@office"         . ?o) ; general office tasks (un-bucketed)
          ("@read"           . ?r) ; books and reading nook items
          ("@review"         . ?R) ; periodic review - timed reminders (tickler)
          ("@scheduling"     . ?d) ; calendar work, planning, conflict resolution
          ("@self"           . ?S) ; personal reflection and planning
          ("@sprint"         . ?s) ; sprint work (primarily development)
          ("@travel"         . ?t) ; trip planning, packing, and similar
          ("@workstation"    . ?w) ; home and office hardware, configurations, etc...
          ("BLOCKED"         . ?B) ; some pre-requisite exists
          ("IMPORTANT"       . ?I) ; something of significance or of great value
          ("NEXT"            . ?N) ; the very next thing to be doing within a project
          ("PROJECT"         . ?P) ; something that takes significant effort or time, and can be decomposed into individual tasks
          ("URGENT"          . ?U) ; something that demands attention in a short time-span
          ("WAITING"         . ?W) ; pending somebody else's next action (similar to blocked)
          ("braindead"       . ?b) ; things that can be done with little thought
          ("journal"         . ?j) ; journaling
          ("noexport"        . ?x)))
#+end_src


*** TODO Fix inherited tag overrides
For whatever reason my agenda is still showing inherited tags.

For speedup purposes, I could define tags on every file instead of using inheritance.
#+begin_src emacs-lisp
(setopt org-use-tag-inheritance nil
        org-agenda-use-tag-inheritance nil
        org-tags-exclude-from-inheritance '("PROJECT" "NEXT"))
#+end_src


*** TODO Archiving
I typically only look back a sprint, about two weeks, for recent time tracking.

Thankfully, John Wiegley shared [[https://orgmode.org/list/m21wc7dz4r.fsf@newartisans.com/][a solution]] for this that I now use. Although, it doesn't quite work yet. Do I have the
right hooks set?

#+begin_src emacs-lisp
(defvar org-my-archive-expiry-days 15
  "The number of days after which a completed task should be auto-archived.
This can be 0 for immediate, or a floating point value.")

(defun org-my-archive-done-tasks ()
  "Archive completed org tasks."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((done-regexp
           (concat "\\* \\(" (regexp-opt org-done-keywords) "\\) "))
          (state-regexp
           (concat "- State \"\\(" (regexp-opt org-done-keywords)
                   "\\)\"\\s-*\\[\\([^]\n]+\\)\\]")))
      (while (re-search-forward done-regexp nil t)
        (let ((end (save-excursion
                     (outline-next-heading)
                     (point)))
              begin)
          (goto-char (line-beginning-position))
          (setq begin (point))
          (if (re-search-forward state-regexp end t)
              (let* ((time-string (match-string 2))
                     (when-closed (org-parse-time-string time-string)))
                (if (>= (time-to-number-of-days
                         (time-subtract (current-time)
                                        (apply #'encode-time when-closed)))
                        org-my-archive-expiry-days)
                    (org-archive-subtree)))
            (goto-char end)))))
    (save-buffer)))

(setopt safe-local-variable-values (quote ((after-save-hook archive-done-tasks))))

(defalias 'archive-done-tasks 'org-my-archive-done-tasks)
#+end_src


** Org Habit
=org-habit= is helpful for keeping track of periodic todos that are or should be habitual. It's a little bit more
lenient in scheduling than using scheduled days, recurrences, or deadlines in that you can set min and max repeat
ranges. Most importantly, it visually displays a habit graph useful for seeing how you're keeping up with these habits.

#+begin_src emacs-lisp
(setopt org-habit-preceding-days 21
        org-habit-following-days 7
        org-habit-graph-column 96
        org-habit-show-all-today t)
#+end_src


** Org Clocking
Org-mode gives us the ability to track time by clocking in and out of headlines. Combined with to-do items and agendas,
we can really get some value out of this functionality.

#+begin_src emacs-lisp
(setopt org-clock-continuously t
        org-clock-in-resume t
        org-clock-into-drawer 1
        org-clock-out-remove-zero-time-clocks t
        org-clock-out-when-done t
        org-clock-persist t
        org-clock-report-include-clocking-task t
        org-treat-insert-todo-heading-as-state-change t
        org-expiry-inactive-timestamps t
        org-log-done 'time
        org-log-into-drawer "LOGBOOK"
        org-clock-in-switch-to-state "STARTED")

;; TODO: Move these somewhere more appropriate
(setopt org-src-window-setup 'current-window)
(setq org-html-postamble nil)

(org-clock-persistence-insinuate); Resume clocking task when emacs is restarted
#+end_src


** Org Linking
Org-mode supports creating links to various resources across org-mode files and materials online.

Let's create some short links for things I might reference often.

#+begin_src emacs-lisp
;; Links - use like: cpan:HTML or rfc-txt:7522
(setopt org-link-abbrev-alist
        '(("rfc-html" . "https://tools.ietf.org/html/rfc%s")
          ("rfc-txt"  . "https://tools.ietf.org/rfc/rfc%s.txt")
          ("rfc-pdf"  . "https://tools.ietf.org/pdf/rfc%s.pdf")
          ("fhir-r4"  . "https://www.hl7.org/fhir/R4/%s")
          ("us-core"  . "https://www.hl7.org/fhir/us/core/%s")
          ("cpan"     . "https://metacpan.org/search?q=%s")
          ("so"       . "https://stackoverflow.com/search?q=%s")
          ("soq"      . "https://stackoverflow.com/questions/%s")
          ("ese"      . "https://emacs.stackexchange.com/search?q=%s")
          ("eseq"     . "https://emacs.stackexchange.com/questions/%s")
          ("rdit"     . "https://redd.it/%s")))
#+end_src


** Org Templates
Emacs =org-mode= has builtin templates that allow you to type something like =<s= and hit =TAB= to insert a source
block. We can customize this to add a few I commonly use.

#+begin_src emacs-lisp
(add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
(add-to-list 'org-structure-template-alist '("sh" . "src shell"))
#+end_src


** Org Reporting with =org-ql=
=org-ql= is a package that lets us query our org files with a bit more power and flexibility than default methods. As
such I use =org-ql= to dig a bit deeper into my Org usage. Let's also make it play nice with Helm.

#+begin_src emacs-lisp :tangle no
(use-package orq-ql)

(use-package helm-org-ql
  :after org-ql)
#+end_src

I've set =org-ql= to not tangle for the moment. It's failing with:
#+begin_example
"Package `org-ql' is unavailable"
#+end_example

Yet a very minimal init file with =use-package= and =org-ql= works just fine...

A quick note on writing agenda views using =org-ql-block= syntax from this comment on a [[https://github.com/alphapapa/org-ql/issues/79#issuecomment-787454462][working template]]. It doesn't
look like this will be in =org-ql= until at least v0.8.

#+begin_example
("c" "<c>aptured things"        ;; [1] key  [2] description
  org-ql-block                  ;; [3] function that select items
  '(                            ;; [4] match/query expression
    (property "CAPTURED")       ;;   arg1: org-query expression
    :sort (priority date)       ;;   keyword arg
    :header "xyzzy"             ;;   keyword arg
   )
  ()                            ;; [5] list of extra settings
  ()                            ;; [6] list of files to export to
) ;; end of agenda entry definition
#+end_example


** Org Agenda Commands
Agenda commands are the powerhouse behind =org-mode= and agendas. These allow you to query across your agenda files and
surface reports of varying complexity. It's a great way to get exactly the thing you want, with only a few keystrokes.

Agenda commands have the following form:
#+begin_example
(setq org-agenda-custom-commands
      '(;; (1 key) (2 description (optional)) (3 type of search) (4 search term)
        ("c" "Desk Work" tags-todo "computer"
         ((org-agenda-files '("~/org/widgets.org" "~/org/clients.org")) ;; (5 settings (optional))
          (org-agenda-sorting-strategy '(priority-up effort-down)))
         ("~/computer.html"))                                           ;; (6 export files (optional))
        ;; ... other commands
        ))
#+end_example

For further reference see the [[https://orgmode.org/worg/org-tutorials/advanced-searching.html][Worg Advanced Searching Tutorial]] or the [[https://orgmode.org/manual/Custom-Agenda-Views.html#Custom-agenda-views][Custom Agenda Views Manual]].

I define these by initializing the commands list with an a weekly preview and append additional templates after. I do
this so I can split the declarations up and describe them better in my literate configuration. I'll initialize a simple
weekly review that shows a span of seven days highlighting stuck projects, open projects, and things awaiting something
to happen.

#+begin_src emacs-lisp
(defvar TT/org-agenda-custom-commands (list) '())

(setq TT/org-agenda-custom-commands
      '(("w" "Weekly Review"
         ((agenda ""
                  ((org-agenda-span 7)))
          (tags "PROJECT")
          (todo "WAITING")))))
#+end_src

Now we can append new search filters to this initialized list which we'll use to initialize the
=org-agenda-custom-commands= variable after.

*** GTD Views
I like to use David Allen's Getting Things Done (GTD) framework for inspiration to my Emacs =org-mode= agenda
management. Here let's define several GTD views for my agenda contents. All of these exist under the =g= agenda group.

1. Inbox - only items captured to the Inbox agenda which are not otherwise visible - consider for refiling to agendas
2. Daily View - combination view of:
   - Priority =A= tasks
   - Today's agenda view
   - Tagged =NEXT= actions
   - A list of open projects
   - Priority =B= tasks
   - Priority =C= tasks
   - All remaining non-prioritized tasks
3. Weekly View - combination view of items planned this week and outstanding delegated/waiting work
4. Next Actions - all todos tagged as a =NEXT= action
5. Review - all todos in the =REVIEW= todo sequence - things other's asked for or need my input on to complete
6. Pending - all todos in the =DELEGATED= todo sequence or tagged as =WAITING=
7. Braindead - all todos tagged with =braindead= - for when you just need to do something without thinking too much

#+begin_src emacs-lisp
(setcdr (last TT/org-agenda-custom-commands)
        `(("g" . "GTD Views")
          ("gi" "Inbox"
           ((alltodo ""
                     ((org-agenda-files '(,TT/org-inbox))
                      (org-agenda-overriding-header "Items in my Inbox")))))
          ("gd" "Daily View"
           ((org-ql-block '(and (priority "A")
                                (not
                                 (or (done)
                                     (tags "PROJECT"))))
                          ((org-ql-block-header "High-Priority Unfinished Tasks")))
            (agenda ""
                    ((org-agenda-span 1)))
            (org-ql-block '(and (not (done))
                                (tags "NEXT"))
                          ((org-ql-block-header "Next Actions")))
            (org-ql-block '(and (not (done))
                                (tags "PROJECT"))
                          ((org-ql-block-header "Open Projects")))
            (org-ql-block '(and (todo)
                                (priority "B")
                                (not
                                 (or (done)
                                     (tags "PROJECT")
                                     (habit)
                                     (planning))))
                          ((org-ql-block-header "B Priority Tasks")))
            (org-ql-block '(and (todo)
                                (priority "C")
                                (not
                                 (or (done)
                                     (tags "PROJECT")
                                     (habit)
                                     (planning))))
                          ((org-ql-block-header "C Priority Tasks")))))
          ("gw" "Weekly View"
           ((agenda ""
                    ((org-agenda-span 7)))
            (org-ql-block '(and (not (done))
                                (ts :from today :to 7))
                          ((org-ql-block-header "1-Week Look Ahead")))
            (org-ql-block '(and (todo)
                                (not (done))
                                (tags "PROJECT"))
                          ((org-ql-block-header "Open Projects")))
            (org-ql-block '(and (not (done))
                                (tags "WAITING"))
                          ((org-ql-block-header "Waiting For")))
            (org-ql-block '(todo "DELEGATED")
                          ((org-ql-block-header "Pending Delegate Completion")))))
          ("gn" "Next Actions"
           ((org-ql-block '(and (not (done))
                                (tags "NEXT"))
                          ((org-ql-block-header "Next Actions")))))
          ("gr" "Review"
           ((org-ql-block '(and (not (done))
                                (todo "REVIEW"))
                          ((org-ql-block-header "For Review")))))
          ("gp" "Pending"
           ((org-ql-block '(and (not (done))
                                (tags "WAITING"))
                          ((org-ql-block-header "Awaiting Response or Action")))
            (org-ql-block '(todo "DELEGATED")
                          ((org-ql-block-header "Pending Delegate Completion")))
            (org-ql-block '(and (not (done))
                                (tags "BLOCKED"))
                          ((org-ql-block-header "Blocked")))))
          ("gb" "Braindead"
           ((org-ql-block '(and (todo)
                                (not (done))
                                (tags "braindead"))
                          ((org-ql-block-header "Braindead")))))))
#+end_src


*** GTD Contexts
I use =org-mode= tags starting with an '@' symbol to designate a context. A context is a physical space, head-space, or
tool that a set of work is associated with.

These aren't too fancy, namely a bunch of searches for context tags. I reuse the binding from the quick tag for
consistency. I want to narrow in on unfinished work in a certain context so I can batch tasks in a context together when
I'm working in that context.

#+begin_src emacs-lisp
(setcdr (last TT/org-agenda-custom-commands)
        '(("@" . "Context Filters")
          ("@a" "Administrative"
           ((org-ql-block '(and (not (done))
				(tags "@administrative"))
                          ((org-ql-block-header "Open Administrative Tasks:")))))
          ("@c" "Career"
           ((org-ql-block '(and (not (done))
				(tags "@career"))
                          ((org-ql-block-header "Open Career Tasks:")))))
          ("@m" "Communication"
           ((org-ql-block '(and (not (done))
				(tags "@communication"))
                          ((org-ql-block-header "Open Communication Tasks:")))))
          ("@f" "Finance"
           ((org-ql-block '(and (not (done))
				(tags "@finances"))
                          ((org-ql-block-header "Open Financial Tasks:")))))
          ("@g" "Guild and Community of Practice"
           ((org-ql-block '(and (not (done))
				(tags "@guild"))
                          ((org-ql-block-header "Open Guild Tasks:")))))
          ("@h" "Health and Wellness"
           ((org-ql-block '(and (not (done))
				(tags "@health"))
                          ((org-ql-block-header "Open Health and Wellness Tasks:")))))
          ("@i" "Hiring"
           ((org-ql-block '(and (not (done))
				(tags "@hiring"))
                          ((org-ql-block-header "Open Hiring Tasks:")))))
          ("@H" "Home"
           ((org-ql-block '(and (not (done))
				(tags "@home"))
                          ((org-ql-block-header "Open Home Tasks:")))))
          ("@l" "Learning Agenda"
           ((org-ql-block '(and (not (done))
				(tags "@learn"))
                          ((org-ql-block-header "Open Learning Agenda Tasks:")))))
          ("@d" "Scheduling"
           ((org-ql-block '(and (not (done))
				(tags "@scheduling"))
                          ((org-ql-block-header "Open Scheduling Tasks:")))))
          ("@s" "Sprint Work"
           ((org-ql-block '(and (not (done))
				(tags "@sprint"))
                          ((org-ql-block-header "Open Sprint Tasks:")))))
          ("@t" "Travel and Planning"
           ((org-ql-block '(and (not (done))
				(tags "@travel"))
                          ((org-ql-block-header "Open Travel Tasks:")))))
          ("@w" "Workstation"
           ((org-ql-block '(and (not (done))
				(tags "@workstation"))
                          ((org-ql-block-header "Open Workstation Tasks:")))))))
#+end_src


*** Priority Matrix Commands
#+begin_src emacs-lisp
(setcdr (last TT/org-agenda-custom-commands)
        '(("p" . "Priority Matrix")
          ("pq" "Quadrants"
           ((org-ql-block '(and (todo)
                                (not (done))
                                (tags "IMPORTANT" "URGENT"))
                          ((org-ql-block-header "Urgent")))
            (org-ql-block '(and (todo)
                                (not (done))
                                (tags "IMPORTANT")
                                (not (tags "URGENT")))
                          ((org-ql-block-header "Important")))
            (org-ql-block '(and (todo)
                                (not (done))
                                (tags "URGENT")
                                (not (tags "IMPORTANT")))
                          ((org-ql-block-header "Delegate")))
            (org-ql-block '(and (todo)
                                (not (done))
                                (not (habit))
                                (not (tags "URGENT" "IMPORTANT")))
                          ((org-ql-block-header "Decline")))))
          ("p1" "Q1"
           ((org-ql-block '(and (todo)
                                (not (done))
                                (tags "IMPORTANT" "URGENT"))
                          ((org-ql-block-header "Urgent")))))
          ("p2" "Q2"
           ((org-ql-block '(and (todo)
                                (not (done))
                                (tags "IMPORTANT")
                                (not (tags "URGENT")))
                          ((org-ql-block-header "Important")))))
          ("p3" "Q3"
           ((org-ql-block '(and (todo)
                                (not (done))
                                (tags "URGENT")
                                (not (tags "IMPORTANT")))
                          ((org-ql-block-header "Delegate")))))
          ("p4" "Q4"
           ((org-ql-block '(and (todo)
                                (not (done))
                                (not (habit))
                                (not (tags "URGENT" "IMPORTANT")))
                          ((org-ql-block-header "Decline")))))))
#+end_src


*** Deadline Review
#+begin_src emacs-lisp
(setcdr (last TT/org-agenda-custom-commands)
        '(("x" "With Deadline Columns"
           ((alltodo ""
                     ((org-agenda-overriding-columns-format "%20ITEM %DEADLINE")
                      (org-agenda-view-columns-initially t)))))
          ("X" "Upcoming Deadlines"
           ((agenda ""
                    ((org-agenda-entry-types '(:deadline))
                     (org-agenda-span 1)
                     (org-deadline-warning-days 60)
                     (org-agenda-time-grid nil)))))))
#+end_src

**** TODO Fix "With Deadline Columns" Filter


*** Hygiene Queries
#+begin_src emacs-lisp
(setcdr (last TT/org-agenda-custom-commands)
        '(("H" . "Hygiene Filters")
          ("Hi" "Incomplete Sub-Tasks"
           ((org-ql-block '(and (todo)
                                (not (done))
                                (ancestors (done)))
                          ((org-ql-block-header "Incomplete Sub-Tasks")))))
          ("Hd" "Projects without Open Tasks"
           ((org-ql-block '(and (not (done))
                                (tags "PROJECT")
                                (not (children (not (done)))))
                          ((org-ql-block-header "Projects with Completed Children")))))
          ("Hn" "Projects without NEXT Tasks"
           ((org-ql-block '(and (tags "PROJECT")
                                (not
                                 (or (done)
                                     (descendants (and (not (done))
                                                       (tags "NEXT"))))))
                          ((org-ql-block-header "Projects without NEXT Action")))))
          ("Hp" "Missing Priority"
           ((org-ql-block '(and (todo)
                                (not
                                 (or (done)
                                     (todo "MEET" "MEETING" "APPOINTMENT")
                                     (habit)
                                     (priority))))
                          ((org-ql-block-header "Missing Priority")))))))
#+end_src


*** TODO Archive Queries
Verify these work. I picked them up from a worg demo or something but haven't used them.

#+begin_src emacs-lisp
(setcdr (last TT/org-agenda-custom-commands)
        '(("Q" . "Custom Queries")
          ("Qa" "Archive Search"
           ((search ""
                    ((org-agenda-files
                      (file-expand-wildcards "~/org/archive/*.org"))))))
          ("QA" "Archive Tags Search"
           ((org-tags-view ""
                           ((org-agenda-files
                             (file-expand-wildcards "~/org/archive/*.org"))))))))
#+end_src


*** Setting Agenda Commands
Lastly I set =org-agenda-custom-commands= to the value of the list I've built.

#+begin_src emacs-lisp
(setq org-agenda-custom-commands TT/org-agenda-custom-commands)
#+end_src

**** TODO Convert to =setopt=
- currently getting type warning
- my agenda is too long to want to debug now, works so far despite the warning


** Org Journal
Let's set up where my journal files are stored, and the format of the entries.
org-jour
#+begin_src emacs-lisp
(use-package org-journal
  :init (setopt org-journal-dir TT/org-journal-dir
                org-journal-file-format "%Y%m%d.org"
                org-journal-date-format "%e %b %Y (%A)")
  :custom
  (org-journal-date-prefix "#+TITLE: Daily Note for "))
#+end_src

*** Journal Helpers
These are functions that will later enable us to interact with org-journal via capture templates, etc...

#+begin_src emacs-lisp
(defun get-journal-file-yesterday ()
  "Gets filename for yesterday's journal entry."
  (let* ((yesterday (time-subtract (current-time) (days-to-time 1)))
         (daily-name (format-time-string "%Y%m%d" yesterday)))
    (expand-file-name (concat org-journal-dir daily-name))))

(defun journal-file-yesterday ()
  "Create and load a file based on yesterday's date."
  (interactive)
  (find-file (get-journal-file-yesterday)))

(defun org-journal-find-location ()
  "Open today's journal.
Specify a non-nil prefix to inhibit inserting the heading"
  (org-journal-new-entry t)
  (goto-char (point-min)))
#+end_src


** Org Capture Templates
Capture templates allow us to quickly invoke a key-chord and select a template to capture some thought directly to a
good home for it. Tasks to my organizer or inbox, new journal items to my journal, etc...

I define these by initializing my capture list with an inbox capture and appending additional templates after. I do this
so I can split the configuration up and describe them better in my literate configuration.

#+begin_src emacs-lisp
;; Org Capture Configuration
(defvar TT/org-capture-templates (list) '())

;; The list needs to be initialized for setcdr to work later
(setq TT/org-capture-templates
      '(("i" "Inbox" entry  (file+olp TT/org-inbox "Capture" "Todos")
         "* TODO %?\n /Entered on/ %U" :empty-lines 1)))
#+end_src

*** Helper Functions
Lets set up helpers. These are functions I'll use in my capture templates to extend the functionality of templates
themselves. These help make decisions, generate names, and do anything else I could need.

#+begin_src emacs-lisp
;;; BEGIN Capture Helpers
(defun region-to-clocked-task (start end)
  "Copies the selected text, from START to END, to the currently clocked in `org-mode` task."
  (interactive "r")
  (org-capture-string (buffer-substring-no-properties-start end) "C"))
(global-set-key (kbd "C-<F1>") 'region-to-clocked-task)

(defun capture-incident-response-file (path)
  "Generate dated file at capture PATH using interactively provided description."
  (interactive)
  (let ((name (read-string "Alert Name: ")))
    (expand-file-name
     (format "%s_%s.org" (format-time-string "%Y%m%d") name)
     path)))

(defun org-capture-inbox ()
  "Capture to inbox."
  (interactive)
  (call-interactively 'org-store-link)
  (org-capture nil "i"))
;;; END Capture Helpers
#+end_src


*** Sprint Work
Here I define my first capture group for Sprint Work. All templates within capture some work associated directly with
the current sprint I'm working in.

As a manger I don't presently do the sprint work that my teams execute, so this configuration is not exported. Instead,
I keep it around for reference.

#+begin_src emacs-lisp :tangle no
;; Capture group for Sprint Work
(setcdr (last TT/org-capture-templates)
        '(("s" "Sprint Capture Group")
          ("sd" "Development Task" entry (file+olp TT/org-organizer "Current Sprint" "Development")
           "* TODO [#B] %? :@sprint:TASK:\n")
          ("sv" "Review Task" entry (file+olp TT/org-organizer "Current Sprint" "Review")
           "* TODO [#B] %? :@sprint:TASK:\n")
          ("sr" "Research Task" entry (file+olp TT/org-organizer "Current Sprint" "Research")
           "* TODO [#B] RESEARCH: %? :@sprint:TASK:\n")
          ("ss" "Spike Task" entry (file+olp TT/org-organizer "Current Sprint" "Research")
           "* TODO [#B] SPIKE: %? :@sprint:TASK:\n")
          ("si" "Interrupt" entry (file+olp TT/org-organizer "Current Sprint" "Other")
           "* TODO [#A] %? :@sprint:TASK:URGENT:\n")
          ("st" "Other Task" entry (file+olp TT/org-organizer "Current Sprint" "Other")
           "* TODO [#B] %? :@sprint:TASK:\n")))
#+end_src


*** Sprint Retrospective Items
This second capture group is for capturing information observations and information related to how the sprint is
going. Capture in the moment, make sense through reflection, synthesize for retrospective and present to the
team. That's the general idea.

#+begin_src emacs-lisp
;; Capture Group for Retrospective Items
(setcdr (last TT/org-capture-templates)
        '(("r" "Retrospective Capture Group")
          ("rk" "Kudos" item (file+olp TT/org-retrospective "Capture" "Kudos")
           "- %?")
          ("rg" "Goodness" item (file+olp TT/org-retrospective "Capture" "Goodness")
           "- %?")
          ("rb" "Badness" item (file+olp TT/org-retrospective "Capture" "Badness")
           "- %?")
          ("rz" "Kaizen" item (file+olp TT/org-retrospective "Capture" "Kaizen")
           "- %?")))
#+end_src


*** TODO Periodic Reflection Capture
In addition to regular retrospectives, it is useful to do other periodic reflections that support inspection and
adaptation.

I plan to add a few capture templates here for things like:
- [ ] Adding to a hype-document (capturing wins)
- [ ] Adding to a list of grievances (capturing things that bug me for later review)
  - This review could be useful for cooling off and deciding whether or not I was justified in being bugged
- [ ] Other things maybe?


*** Office Work Capture
As I made the transition from engineering work to management I found myself overusing the "office" context I originally
had for non-development in-office work. This capture group helps me better capture tasks I find myself regularly doing
as a manager, and better categorizes things within sub-groups of the "office" context.

#+begin_src emacs-lisp
;; Capture Group for Office Work
(setcdr (last TT/org-capture-templates)
        '(("o" "Office Capture Group")
          ("oa" "Administrative" entry (file+olp TT/org-organizer "Office" "Administrative")
           "* TODO [#B] %? :@office:@administrative:\n")
          ("oc" "Communication" entry (file+olp TT/org-organizer "Office" "Communication")
           "* TODO [#B] %? :@office:@communication:\n")
          ("of" "Firefighting" entry (file+olp TT/org-organizer "Office" "Firefighting")
           "* TODO [#A] %? :@office:@firefights:URGENT:\n")
          ("oh" "Hiring" entry (file+olp TT/org-organizer "Office" "Hiring")
           "* TODO [#B] %? :@office:@hiring:\n")
          ("oi" "Interrupts" entry (file+olp TT/org-organizer "Office" "Interrupts")
           "* TODO [#B] %? :@office:\n")
          ("os" "Scheduling" entry (file+olp TT/org-organizer "Office" "Scheduling")
           "* TODO [#B] %? :@office:@scheduling:\n")
          ("ot" "Task" entry (file+olp TT/org-organizer "Office" "General")
           "* TODO [#B] %? :@office:\n")))
#+end_src


*** Organizer To Do Items
This capture group is for non-sprint related tasks, which should each go to their proper group and have a default
priority based on how I typically file similar tasks. These can easily be adjusted up or down via the agenda view, so
it's perfectly fine for them to be inaccurate for the task, as long as they're typically correct.

Ideally there should be a capture template direct to every single level headline in my organizer. Each headline with
sub-headings ideally will have it's own capture group

#+begin_src emacs-lisp
;; Non-Sprint Todo Capture Group
(setcdr (last TT/org-capture-templates)
        '(("t" "General Todo Capture Group")
          ("tc" "Career Task" entry (file+headline TT/org-organizer "Career")
           "* TODO [#B] %? :@career:\n")
          ("th" "Health Task" entry (file+headline TT/org-organizer "Health & Wellness")
           "* TODO [#B] %? :@health:\n")
          ("to" "Home Task" entry (file+headline TT/org-organizer "Home")
           "* TODO [#B] %? :@home:\n")
          ("tf" "Financial Task" entry (file+headline TT/org-organizer "Finances")
           "* TODO [#B] %? :@finances:\n")
          ("tg" "Guild Task" entry (file+headline TT/org-organizer "Guild")
           "* TODO [#C] %? :@guild:\n")
          ("tr" "Reading Task" entry (file+headline TT/org-organizer "Reading")
           "* TODO [#B] %? :@read:\n")
          ("tv" "Travel Task" entry (file+headline TT/org-organizer "Travel")
           "* TODO [#B] %? :@travel:\n")
          ("tw" "Workstation Task" entry (file+headline TT/org-organizer "Workstation")
           "* TODO [#C] %? :@workstation:\n")
          ("tt" "General Task" entry (file+headline TT/org-organizer "Tasks")
           "\n* TODO [#C] %?\n %i\n %a\n\n")))
#+end_src


*** TODO Incubator
Sometimes I want to capture an idea that I know I cannot take immediate action on. Instead of adding noise to my agenda
reports, let's file these as someday-maybe under =TT/org-incubate-dir=.


*** Meetings
This capture group is for meetings tied to the calendar.

I'd prefer to auto-populate the date with today's date and the repeat offset, but haven't found a smooth way to do it
yet. So for now, I schedule to an arbitrary date and update the date with =C-s= as I fill out the template.

#+begin_src emacs-lisp
;; Capture Group for Meetings
(setcdr (last TT/org-capture-templates)
        '(("m" "Meeting Capture Group")
          ("mm" "Pop Up Meetings and One-Offs" entry (file+olp TT/org-calendar "Meetings" "One Offs")
           "* MEET %?\nSCHEDULED: %^t")
          ("md" "Daily Meeting" entry (file+olp TT/org-calendar "Meetings" "Daily")
           "* MEET %?\nSCHEDULED: <2020-01-01 Sat ++1d>")
          ("mw" "Weekly Meeting" entry (file+olp TT/org-calendar "Meetings" "Weekly")
           "* MEET %?\nSCHEDULED: <2020-01-01 Sat ++1w>")
          ("m1" "1:1 Meeting" entry (file+olp TT/org-calendar "Meetings" "1:1s")
           "* MEET %?\nSCHEDULED: <2000-01-01 Sat ++1w>")
          ("mb" "Bi-Weekly Meeting" entry (file+olp TT/org-calendar "Meetings" "Bi-Weekly")
           "* MEET %?\nSCHEDULED: <2000-01-01 Sat ++2w>")))
#+end_src


*** Journal
Capture templates for journaling. Contains a basic capture, and a few templates for structured entries.

#+begin_src emacs-lisp
(setcdr (last TT/org-capture-templates)
        `(("j" "Journal Capture Group")
          ("jd" "Daily Goals" entry (function org-journal-find-location)
           (file ,(concat TT/org-cap-templates-dir "/daily-goals.org"))
           :empty-lines 1)
          ("jj" "Journal" entry (function org-journal-find-location)
           "* %(format-time-string org-journal-time-format)%^{Title}\n%i%?")))
#+end_src


*** Miscellaneous
The remaining capture templates are things that don't fit neatly into any one group.

#+begin_src emacs-lisp
;; Other Capture Templates (un-grouped)
(setcdr (last TT/org-capture-templates)
        `(("n" "Note" entry (file+olp TT/org-inbox "Capture" "Notes")
           "* %?\n:PROPERTIES:\n:CREATED:%U\n:END:\n\n%i\n\nFrom: %a"
           :empty-lines 1)
          ("m" "Manager Notes" item (file+olp TT/org-manager "1:1 Prep" "Capture")
           "- %?" :empty-lines 1)
          ("x" "Incident Notes" entry (file (capture-incident-response-file "~/org/incidents"))
           (file ,(concat TT/org-cap-templates-dir "/incident.org"))
           :clock-in t)
          ("X" "Item to Current Clock" item
           (clock)
           "%i%?" :empty-lines 1)
          ("C" "Region to Current Clock" plain
           (clock)
           "%i" :immediate-finish t :empty-lines 1)))
#+end_src

**** TODO Needs Work [0/1]
- [ ] The =C-c c x= 'Incident Notes' capture template isn't working
 #+begin_example
 Invalid file location: nil
 #+end_example


*** Nested Groups Test
I had a hypothesis that I might be able to progressively define nested capture groups. This is the experiment that
showed it was possible. I keep it around for reference, but no longer export it into my configuration.

#+begin_src emacs-lisp :tangle no
;; Test capture group - testing nested sub-groups
(setcdr (last TT/org-capture-templates)
        '(("q" "Test Capture Group")
          ("qa" "Test Capture Sub-Group A")
          ("qaa" "AA Template" entry (file+olp TT/org-inbox "Test" "A" "AA")
           "* TODO [#A] %? :TASK:\n" :empty-lines 1)
          ("qaa" "AB Template" entry (file+olp TT/org-inbox "Test" "A" "AB")
           "* TODO [#B] %? :TASK:\n" :empty-lines 1)
          ("qb" "Test Capture Sub-Group B")
          ("qba" "BA Template" entry (file+olp TT/org-inbox "Test" "B" "BA")
           "* TODO [#A] %? :TASK:\n" :empty-lines 1)
          ("qbb" "BB Template" entry (file+olp TT/org-inbox "Test" "B" "BB")
           "* TODO [#B] %? :TASK:\n" :empty-lines 1)))
#+end_src


*** Setting Capture Templates
Because I've split the configuration up, it's time to update the actual =org-capture-templates= variable.

#+begin_src emacs-lisp
(setq org-capture-templates TT/org-capture-templates)
#+end_src

If I want to further customize this variable in machine local configurations, like in my employer configuration, I'll
have to append to =org-capture-templates=. I could wait to set the value at the very end, but right now I think it makes
more sense to keep local to this section.


** Org Refile
Despite having some nice capture templates, sometimes things still don't end up in the right place. That, or sometimes I
just want to move something.

#+begin_src emacs-lisp
(setopt org-refile-targets `((org-agenda-files :maxlevel . 6)
                             (,TT/org-ideas :maxlevel . 3)
                             (,TT/org-maybe-projects :maxlevel . 2)
                             (,TT/org-someday :maxlevel . 4)))
;;(setq org-outline-path-complete-in-steps nil)
(setopt org-refile-allow-creating-parent-nodes 'confirm)
#+end_src


** Org Publish
I can even use org-mode to publish static content!

#+begin_src emacs-lisp
(setq org-publish-project-alist
      '(("notes-content"
         :base-directory "~/org/testnotes"
         :base-extension "org"
         :publishing-directory "~/public_html/"
         :recursive t
         :publishing-function org-html-publish-to-html
         :headline-levels 4
         :auto-preamble t)
        ("notes-static"
         :base-directory "~/org/testnotes"
         :base-extensions "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf"
         :publishing-directory "~/public_html" ; could be TRAMP path
         :recursive t
         :publishing-function org-publish-attachment)
        ("notes" :components ("notes-content" "notes-static"))))

;; TODO: https://github.com/fniessen/org-html-themes or other
#+end_src

*** TODO Publish Research [0/6]
- [ ] =ox-slimhtml=
- [ ] https://edwardtufte.github.io/tufte-css/
  - https://edwardtufte.github.io/et-book/
- [ ] https://github.com/fniessen/org-html-themes
- [ ] https://orgmode.org/worg/org-web.html
- [ ] https://orgmode.org/worg/org-tutorials/org-latex-export.html
- [ ] https://orgmode.org/worg/org-blog-articles.html


*** TODO Org Presentation Research [0/1]
- [ ] https://github.com/yjwen/org-reveal


** Org-Babel

*** Supporting Tools
Using org-babel, we can pull in some graphical helper tools to give it some rendering capabilities.

#+begin_src emacs-lisp
(setopt org-ditaa-jar-path "/usr/bin/ditaa.jar")
(setopt org-plantuml-jar-path "/usr/share/plantuml/plantuml.jar")
#+end_src


*** Displaying Inline Images
Let's make it so org-babel can display images in org files directly.

#+begin_src emacs-lisp
(defun bh/display-inline-images ()
  "Display inline images."
  (condition-case nil
      (org-display-inline-images)
    (error nil)))

(add-hook 'org-babel-after-execute-hook 'bh/display-inline-images 'append)
#+end_src


*** Configuring Supported Languages
I'm only going to configure the subset of languages I use, but there are way more to choose from.

#+begin_src emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((C          . t)
   (ditaa      . t)
   (dot        . t)
   (emacs-lisp . t)
   (gnuplot    . t)
   (js         . t)
   (latex      . t)
   (ledger     . t)
   (org        . t)
   (perl       . t)
   (plantuml   . t)
   (python     . t)
   (shell      . t)
   (sql        . t)
   (sqlite     . t)))
#+end_src


*** Final Things
With =org-babel= mostly configured, lets plug it into some other stuff.

#+begin_src emacs-lisp
(add-to-list 'org-src-lang-modes '("plantuml" . fundamental))
#+end_src


** TODO Org References
I want to refile these closer to where their contents are more applicable.

- https://orgmode.org/manual/Template-elements.html
- https://orgmode.org/manual/Template-expansion.html
- https://orgmode.org/manual/Refile-and-Copy.html
- https://orgmode.org/manual/Configuration.html Projects for publishing


* Development Interactions
This section contains customization for development and working within coding environments.

** General Settings
A few things across languages first.

*** Tabs v. Spaces
Let the holy wars be resolved by tooling that enables each developer to see things their way in their editor, and
tooling that converts these to whatever is standard for the code base we collaborate in.

Set tabbing to spaces, keep things condensed with 2 spaces.

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
(setq tab-width 2)
#+end_src


** Editor Config
See [[https://editorconfig.org/][EditorConfig.org]] for more details. However, this helps me play nice across source repositories, and helps keep contributors
happily using their own editor/IDE.

#+begin_src emacs-lisp
(use-package editorconfig
  :diminish editorconfig-mode
  :config
  (editorconfig-mode 1))
#+end_src


** TODO Language Server
The Language Server Protocol (LSP) sets up a contract for an editor (client) to chat with a language server to reduce
development burden of supporting language interactions across languages and editors. Instead, the server can worry about
supporting language interactions and any editor with a client can get the benefit of that abstraction.

Emacs has both the [[https://github.com/emacs-lsp/lsp-mode][lsp-mode]] and [[https://github.com/joaotavora/eglot][eglot]] packages to support client interfaces with various language server backends. I've
chosen to leverage =lsp-mode= as my language server client.

#+begin_src emacs-lisp
;; LSP mode configuration
(use-package lsp-mode
  :commands lsp
  :init (setq lsp-keymap-prefix "C-c l")
  :hook (c++-mode
         go-mode
         js2-mode
         rust-mode
         python-mode)
  :custom
  (lsp-prefer-flymake nil)
  (gc-cons-threshold (* 100 1024 1024))
  (read-process-output-max (* 1024 1024))
  (lsp-idle-delay 0.200)
  (lsp-log-io nil)
  (lsp-modeline-diagnostics-scope :workspace))
#+end_src

*** Language Server UI Modules with =lsp-ui=
#+begin_src emacs-lisp
(use-package lsp-ui
  :commands lsp-ui-mode
  :after lsp-mode)
#+end_src


*** =dap-mode= Debugger Integration
#+begin_src emacs-lisp
(use-package dap-mode
  :after lsp-mode
  :commands dap-debug
  :hook ((python-mode . dap-ui-mode)
         (python-mode . dap-mode))
  :config
  (require 'dap-python)
  (require 'dap-cpptools)
  (require 'dap-chrome)
  (setq dap-python-debugger 'debugpy)
  (defun dap-python--pyenv-executable-find (command)
    (with-venv (executable-find "python")))
  (add-hook 'dap-stopped-hook
            (lambda (arg) (call-interactively #'dap-hydra))))
#+end_src


*** =helm= Integration
#+begin_src emacs-lisp
(use-package helm-lsp
  :after (lsp-mode helm)
  :commands helm-lsp-workspace-symbol
  :after lsp-mode)
#+end_src


*** =treemacs= Integration
#+begin_src emacs-lisp
(use-package lsp-treemacs
  :commands lsp-treemacs-error-list
  :after (lsp-mode treemacs-mode)
  :custom
  (treemacs-indentation 2)
  (treemacs-width 32)
  (treemacs-git-integration t)
  (treemacs-sorting 'alphabetic-desc)
  (treemacs-show-hidden-files t)
  :config
  (treemacs-filewatch-mode t))
#+end_src


*** Installing LSP Implementations
In addition to the Emacs packages, you'll need to install language servers for the languages you'll be working in. Some
of these can be installed using the Emacs function =M-x lsp-install-server=, while others will be done via your system's
package manager.

For more on Emacs LSP support, see [[https://emacs-lsp.github.io/lsp-mode/page/languages/][emacs-lsp languages]].

For me, this involves using =lsp-install-server= for:
- =css-ls=
- =dockerfile-ls=
- =eslint=
- =json-ls=
- =marksman=
- =sql-ls=
- =svelte-ls=
- =yamlls=

And using system installation for:
- =python3-pylsp=
- =cargo= + texlab

#+begin_src shell :tangle no
cargo install --locked --git https://github.com/latex-lsp/texlab.git
#+end_src



** Company Completions
Company-mode, or complete any mode, is an extremely useful tool for text/code completion.

#+begin_src emacs-lisp
(use-package company
  :diminish
  :hook ((prog-mode . company-mode)
         (text-mode . company-mode))
  :bind (:map company-active-map
              ("M-n" . nil)
              ("M-p" . nil)
              ("C-n" . company-select-next)
              ("C-p" . company-select-previous))
  :custom
  (company-idle-delay nil)
  (company-tooltip-align-annotations t)
  (company-minimum-prefix-length 2)
  (company-require-match nil)
  (company-show-numbers t)
  (company-tooltip-limit 20)
  :config
  (global-company-mode)
  (with-eval-after-load 'company
    (global-set-key (kbd "C-c SPC") 'company-complete)))
#+end_src


** Project Management with =projectile=
Projectile allows for project interaction from within Emacs. Additionally, it can hook into other powerful search
utilities to really kick up project navigation.

#+begin_src emacs-lisp
(use-package projectile
  :after (helm)
  :delight '(:eval (concat " {" (projectile-project-name) "}"))
  :bind (:map projectile-mode-map
              ("S-p" . projectile-command-map)
              ("C-c p" . projectile-command-map))
  :custom
  (projectile-completion-system 'helm)
  (projectile-switch-project-action 'helm-projectile)
  (projectile-enable-caching t)
  (projectile-globally-ignored-directories '(".git" "node_modules" "__pycache__" ".vs" ".venv"))
  (projectile-globally-ignored-file-suffixes '(".swp" ".o" ".so" ".exe" ".dll" ".elc" ".pyc" ".jar" ".cache"))
  (projectile-globally-ignored-files '("TAGS" "tags"))
  (projectile-project-search-path '("~/devel/projects/"))
  :config
  (projectile-mode))
#+end_src

And integrate with =helm=.

#+begin_src emacs-lisp
(use-package helm-projectile
  :after (helm projectile)
  :bind ("M-t" . helm-projectile-find-file)
  :config
  (helm-projectile-on))
#+end_src


** Magical Git Interactions with =magit=
#+begin_src emacs-lisp
(setopt vc-handled-backends (delq 'Git vc-handled-backends))

(use-package magit
  :bind ("C-x g" . magit-status))
   #+end_src

*** Access Git Forges with =forge=

#+begin_src emacs-lisp
(use-package forge
  :after magit)
#+end_src


** Project and Directory Viewing with =treemacs=
Bring a tree layout file explorer to Emacs with =treemacs=. Integrate =treemacs= with =projectile= and =magit= for a
richer set of programming interactions.

#+begin_src emacs-lisp
(use-package treemacs
  :diminish
  :bind
  (:map global-map
        ("M-0"       . treemacs-select-window)
        ("C-x t 1"   . treemacs-delete-other-windows)
        ("C-x t t"   . treemacs)
        ("C-x t B"   . treemacs-bookmark)
        ("C-x t C-t" . treemacs-find-file)
        ("C-x t M-t" . treemacs-find-tag))
  :custom
  (treemacs-collapse-dirs 3)
  (treemacs-indentation 2)
  (treemacs-indentation-string " ")
  (treemacs-litter-directories '("/node_modules" "/.venv" "/.cask"))
  (treemacs-sorting 'alphabetic-desc)
  (treemacs-wide-toggle-width 64)
  (treemacs-width 32)
  :config
  (treemacs-follow-mode t)
  (treemacs-filewatch-mode t))

(use-package treemacs-projectile
  :after (treemacs projectile)
  :custom
  (treemacs-header-function #'treemacs-projectile-create-header))

(use-package treemacs-magit
  :after (treemacs magit))
#+end_src


** HTTP Interactions

*** With =restclient=
Interactively making REST calls of a server. Mode associated with =*.http= files.

#+begin_src emacs-lisp
(use-package restclient
  :mode ("\\.http$"))
#+end_src


*** With =verb=
I've recently been experimenting with =verb-mode= as it integrates directly with =org-mode= and has worked pretty much
as is for me.

#+begin_src emacs-lisp
(use-package verb)
#+end_src

This may load after =org-mode= which may cause problems... I may just need to hoist it earlier in the configs or do some
=use-package= dependency linking.


** On The Fly Checking
Fly-Check enables on the fly syntax checking which helps me catch errors as I write them and prompts me to fix them
immediately. This enforces a tight feedback loop in development.

#+begin_src emacs-lisp
(use-package flycheck)

(add-hook 'after-init-hook #'global-flycheck-mode)

(setopt flycheck-checkers
        (quote (asciidoc
                c/c++-cppcheck
                css-csslint
                emacs-lisp
                emacs-lisp-checkdoc
                handlebars
                html-tidy
                javascript-eslint
                json-jsonlint
                less
                make
                perl
                perl-perlcritic
                python-flak8
                python-pylint
                rust
                sh-bash
                sh-zsh
                sh-spellcheck
                tex-chktex
                tex-lacheck
                texinfo
                xml-xmlstarlet
                xml-xmllint
                yaml-jayaml)))
;; Others: cfenging chef-foodcritic coffee coffee-coffeelint d-dmd elixir
;;         erlang eruby-erubis go-gofmt go-golint go-vet go-build go-test
;;         haml haskell-ghc haskell-hlint lua php php-phpmd php-phpcs
;;         puppet-parser puppet-lint racket rst rst-sphinx ruby-rubocop
;;         ruby-rubylint ruby ruby-jruby sass scala scss slim verilog-verilator

(setopt flycheck-disabled-checkers
        '(javascript-jshint
           javascript-jslint
           javascript-gjslint
           c/c++-clang))

;; Enable C++14 support for GCC
(add-hook 'c++-mode-hook (lambda () (setq flycheck-gcc-language-standard "c++14")))

;; Use project relative eslint; see https://emacs.stackexchange.com/questions/21205
(defun TT/use-eslint-from-node-modules ()
  "Use project local eslint node modules."
  (let* ((root (locate-dominating-file
                (or (buffer-file-name) default-directory)
                "node_modules"))
         (eslint (and root
                      (expand-file-name "node_modules/eslint/bin/eslint.js"
                                        root))))
    (when (and eslint (file-executable-p eslint))
      (setq-local flycheck-javascript-eslint-executable eslint))))

(add-hook 'flycheck-mode-hook #'TT/use-eslint-from-node-modules)

;; Enable flycheck globally:
(add-hook 'after-init-hook #'global-flycheck-mode)

;; See: https://emacs.stackexchange.com/questions/13065
;; (defun setup-flycheck-clang-project-path ()
;;   "Use project local clang."
;;   (let ((root (ignore-errors (projectile-project-root))))
;;   (when root
;;     (add-to-list
;;      (make-variable-buffer-local 'flycheck-clang-include-path)
;;      root))))

;; (add-hook 'c++-mode-hook 'setup-flycheck-clang-project-path)
#+end_src


** Containerized Development with =docker=
Some projects I work on use Docker, and Emacs can too!

#+begin_src emacs-lisp
(use-package docker
  :diminish
  :bind ("C-c d" . docker))
#+end_src

*** Edit Docker Compose Files with =docker-compose-mode=
#+begin_src emacs-lisp
(use-package docker-compose-mode
  :mode "docker-compose.*\.yml\\'")
#+end_src


*** Edit Dockerfiles with =dockerfile-mode=
#+begin_src emacs-lisp
(use-package dockerfile-mode
  :mode "Dockerfile[a-zA-Z.-]*\\'")
#+end_src


** Language Configurations
Make sure certain files open in certain modes.

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.hbs$"         . handlebars-mode))
(add-to-list 'auto-mode-alist '("\\.README\\.md$" . gfm-mode))
(add-to-list 'auto-mode-alist '("Jenkinsfile$"    . groovy-mode))
#+end_src

*** Shell with =eshell=
Setup =eshell=.

#+begin_src emacs-lisp
(use-package eshell
  :custom
  (eshell-scroll-to-bottom-on-input 'all)
  (eshell-hist-ignoredups t)
  (eshell-save-history-on-exit t)
  (eshell-prefer-lisp-functions nil)
  (eshell-destroy-buffer-when-process-dies t)
  :config
  (add-hook 'eshell-mode-hook
            (lambda ()
              (add-to-list 'eshell-visual-commands "ssh")
              (add-to-list 'eshell-visual-commands "tail")
              (add-to-list 'eshell-visual-commands "top"))))
#+end_src


**** TODO =helm-eshell= throws error unavailable
And add some helm integration for =eshell=.

#+begin_src emacs-lisp :tangle no
(use-package helm-eshell
  :after (eshell-mode helm)
  :hook eshell-mode
  :bind (:map eshell-mode-map ("C-c C-l" . helm-eshell-history)))
#+end_src


*** Markdown with =markdown-mode=

#+begin_src emacs-lisp
(use-package markdown-mode
  :hook (markdown-mode . lsp)
  :mode (("\\.md$" . markdown-mode)
         ("\\.markdown$" . markdown-mode))
  :config
  (require 'lsp-marksman))
#+end_src


*** SQL and DB Interactions

**** sqlite

Let's enhance the =sqlite= experience by extending =sqlite-mode= with =sqlite-mode-extras=.

#+begin_src elisp
(use-package sqlite-mode-extras
  :hook ((sqlite-mode . sqlite-extras-minor-mode))
  :bind (:map
         sqlite-mode-map
         ("n" . next-line)
         ("p" . previous-line)
         ("<backtab>" . sqlite-mode-extras-backtab-dwim)
         ("<tab>" . sqlite-mode-extras-tab-dwim)
         ("RET" . sqlite-mode-extras-ret-dwim)))
#+end_src


*** Web Development

#+begin_src emacs-lisp
(use-package web-mode
  :mode (("\\.html?\\'" . web-mode)
         ("\\.php\\'" . web-mode)
         ("\\.[agj]sp\\'" . web-mode)
         ("\\.mustache\\'" . web-mode))
  :bind ("C-c w n" . web-mode-tag-match)
  :custom
  (web-mode-markup-indent-offset 2)
  (web-mode-code-indent-offset 2)
  (web-mode-enable-auto-pairing t))
#+end_src

And more specifically for CSS

#+begin_src emacs-lisp
(use-package css-mode
  :mode ("\\.css$" . css-mode))
#+end_src


*** TODO C/C++


*** JavaScript
From time to time I've developed in JavaScript, both in the Web and in Node. =js2-mode= has been good to me for
that.

Recently I've run into problems with =lsp-mode=, =editorconfig-mode=, and JSON's use of =js-json-mode=. I want my
=.editorconfig= values for JS files to read from it, but some combination of the above is winning over those. The below
configs seem to have fixed it, but I'll keep an eye on it when editing JS and JSON files for a bit.

Set up =js2-mode= and =js2-refactor= extensions.

#+begin_src emacs-lisp
(use-package js2-mode
  :after js-mode
  :mode ("\\.js$" . js2-mode)
  :interpreter "node"
  :custom
  (js-indent-level 2)
  (js2-basic-offset 2)
  (js2-highlight-level 3)
  :config
  (define-key js2-mode-map (kbd "M-.") nil)
  (add-hook 'js2-mode-hook
            (lambda ()
              (add-hook 'xref-backend-functions #'xref-js2-xref-backend nil t)))
  (add-hook 'js2-mode-hook
            (lambda ()
              (setq mode-name "js2"))))

(use-package js2-refactor
  :after js2-mode
  :hook (js2-mode . js2-refactor-mode)
  :config
  (define-key js2-mode-map (kbd "C-k") #'js2r-kill)
  (js2r-add-keybindings-with-prefix "C-c C-r"))
#+end_src

Finally we map =rjsx-mode= to =.jsx= files. =js2-mode= has some handling for these files, but I've liked this mode a bit
more so far.

#+begin_src emacs-lisp
(use-package rjsx-mode
  :after js2-mode
  :mode ("\\.jsx" . rjsx-mode))
#+end_src


**** Pretty Printing with =prettier-js=
#+begin_src emacs-lisp
(use-package prettier-js
  :after (js2-mode web-mode)
  :init
  (defun enable-minor-mode (my-pair)
    "Enable minor mode if filename match the regexp.  MY-PAIR is a cons cell (regexp . minor-mode)."
    (if (buffer-file-name)
        (if (string-match (car my-pair) buffer-file-name)
            (funcall (cdr my-pair)))))
  :hook ((js2-mode . prettier-js-mode)
         (web-mode . prettier-js-mode))
  :custom
  (prettier-js-args '("--use-tabs" "false"
                      "--trailing-comma" "all"
                      "--bracket-spacing" "false"))
  :config
  (add-hook 'web-mode-hook #'(lambda ()
                               (enable-minor-mode
                                '("\\.jsx?\\'" . prettier-js-mode)))))
#+end_src


**** =jq= Script Editing with =jq-mode=
#+begin_src emacs-lisp
(use-package jq-mode
  :mode "\\.jq\\'")
#+end_src


**** TypeScript with =typescript-mode=
#+begin_src emacs-lisp
(use-package typescript-mode
  :mode "\\.ts\\'")
#+end_src


**** Svelte with =svelte-mode=
#+begin_src emacs-lisp
(use-package svelte-mode
  :mode "\\.svelte\\'")
#+end_src


*** Perl Customization
I used to write mostly in Perl for work, and =cperl-mode= was what my Emacs wielding colleagues used at my employer. It
was definitely better than the Vanilla Emacs defaults.

#+begin_src emacs-lisp
(use-package cperl-mode
  :custom
  (cperl-close-paren-offset 0)
  (cperl-continued-statement-offset 0)
  (cperl-electric-backspace-untabify nil)
  (cperl-indent-comment-at-column-0 t)
  (cperl-indent-parens-as-block t)
  (cperl-label-offset 0)
  (cperl-min-label-indent 0)
  (perl-tab-to-comment t)
  :config
  (defalias 'perl-mode 'cperl-mode)
  (defvaralias 'c-basic-offset 'tab-width)
  (defvaralias 'cperl-indent-level 'tab-width)

  ;; Override perl-mode with cperl-mode
  (mapc
   (lambda (pair)
     (if (eq (cdr pair) 'perl-mode)
         (setcdr pair 'cperl-mode)))
   (append auto-mode-alist interpreter-mode-alist)))
#+end_src

#+begin_src emacs-lisp
(use-package helm-perldoc
  :after (helm cperl-mode)
  :config
  (helm-perldoc:setup))
#+end_src


*** Python
#+begin_src emacs-lisp
(use-package python-mode
  :mode "\\.py\\'"
  :interpreter "python3")

(use-package with-venv
  :after python-mode)
#+end_src

#+begin_src emacs-lisp
(use-package helm-pydoc
  :after (helm python-mode)
  :bind (:map python-mode-map
         ("C-c C-d" . helm-pydoc)))
#+end_src

**** TODO Formatting with Black


*** Rust
Initial configuration informed through:
- https://robert.kra.hn/posts/rust-emacs-setup/
- https://emacs-lsp.github.io/lsp-mode/page/lsp-rust-analyzer/
- https://github.com/brotzeit/rustic

#+begin_src emacs-lisp
(use-package rust-mode
  :mode "\\.rs\\'")
#+end_src

#+begin_src emacs-lisp
(use-package rustic
  :after rust-mode
  :ensure-system-package (rust-analyzer . "rustup component add rust-analyzer")
  :bind (:map rustic-mode-map
              ("M-j" . lsp-ui-imenu)
              ("M-?" . lsp-find-references))
  :custom
  (rustic-analyzer-command '("rustup" "run" "stable" "rust-analyzer"))
  :custom
  (rustic-format-on-save t)
  (rustic-indent-offset 2))
#+end_src


* More Emacs Modes

** Ledger - Command Line Accounting
Ledger, the command line double booking entry system. A geeky way to track your finances, with support in Emacs via
=ledger-mode=!

#+begin_src emacs-lisp
(use-package ledger-mode
  :mode ("\\.ledger$")
  :bind (:map ledger-mode-map
              ("C-x C-s" . TT/ledger-save))
  :preface
  (defun TT/ledger-save ()
    "Automatically clean the ledger buffer at each save."
    (interactive)
    (save-excursion
      (when (buffer-modified-p)
        (with-demoted-errors (ledger-mode-clean-buffer))
        (save-buffer))))
  :init
  (setq ledger-post-amount-alignment-column 80))

(use-package flycheck-ledger
  :after ledger-mode)
#+end_src


** Internet Relay Chat with =erc=
Emacs comes with it's own Internet Relay Chat client, =erc=. I use this to chat over IRC from right within Emacs.

#+begin_src emacs-lisp
(use-package erc
  :commands erc-tls
  :bind (:map erc-mode-map
              ("RET" . nil)
              ("C-c RET" . erc-send-current-line)
              ("C-c C-RET" . erc-send-current-line))
  :custom
  (erc-nick "paraparity")
  (erc-hide-list '("JOIN" "PART" "QUIT" "NICK"))
  (erc-lurker-hide-list '("JOIN" "PART" "QUIT" "NICK"))
  (erc-prompt-for-password nil)
  (erc-kill-buffer-on-part t)
  (erc-kill-queries-on-quit t)
  (erc-kill-server-buffer-on-quit t)
  (erc-autojoin-timing 'ident)
  (erc-autojoin-channels-alist
   '(("libera.chat"
      "##rust"
      "#bash"
      "#emacs"
      "#erc"
      "#javascript"
      "#node.js"
      "#org-mode"
      "#perl"
      "#python"
      "#systemcrafters")))
  :config
  (add-to-list 'erc-modules 'autojoin)
  (erc-autojoin-mode t))
#+end_src


** PDF-Tools
PDF-Tools enable PDF viewing within Emacs, so I don't have to have a second application open to read and take notes on
PDF files. Just one more reason to never leave Emacs.

Unfortunately my current configuration has trouble doing a fresh install as this has a dependency on =pdf-tools= being
installed on the host running Emacs, which it may not be. On a system with this dependency installed we're up and
running no problem though. As such, I tell =use-package= not to ensure the package is installed and to leave updating to
me as a manual task.

#+begin_src emacs-lisp :tangle no
(use-package pdf-tools
  :ensure nil
  :pin manual
  :mode ("\\.pdf\\'" . pdf-view-mode)
  :config
  (setq-default pdf-view-display-size 'fit-page)
  (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward)
  (pdf-tools-install :no-query))

(use-package org-pdfview
  :ensure nil
  :after pdf-tools)
#+end_src


** Feed Reading with =elfeed=
Feeds are great, and reading them in Emacs is better.

#+begin_src emacs-lisp
(use-package elfeed
  :bind ("C-x w" . elfeed)
  :init (setf url-queue-timeout 30)
  :config
  (if (file-readable-p "~/.emacs.d/elisp/elfeed-conf.el")
      (load-library "elfeed-conf")))
#+end_src

My =elfeed= configuration is machine local for now, as my work and personal machines all represent different contexts
where I pay attention to different things.

#+begin_src emacs-lisp
#+end_src



* TODO Helper Functions
This section contains custom functions I'll sometimes invoke. These should probably live elsewhere, but for now, this is
their home.

#+begin_src emacs-lisp
;; Regardless of which buffer you're in, jump to the active minibuffer
(defun switch-to-minibuffer ()
  "Switch to minibuffer window."
  (interactive)
  (if (active-minibuffer-window)
      (select-window (active-minibuffer-window))
    (error "Minibuffer is not active")))

(defun occur-non-ascii ()
  "Find any non-ascii characters in the current buffer."
  (interactive)
  (occur "[[:nonascii:]]"))

(defun open-config-file ()
  "Open this file."
  (interactive)
  (find-file "~/.emacs.d/configuration.org"))

;; From EmacsWiki: https://www.emacswiki.org/emacs/FlySpell#h5o-16
(defun flyspell-learn-word-at-point ()
  "Takes the highlighted word at point and insert it into the personal/private dictionary."
  (interactive)
  (let ((current-location (point))
	(word (flyspell-get-word)))
    (when (consp word)
      (flyspell-do-correct
       'save nil
       (car word)
       current-location
       (cadr word)
       (caddr word)
       current-location))))
  #+end_src

** Reload Configuration
Ideal for when I've edited my configuration and want to re-load my configuration. My =init.el= tangles and loads my
literate config, so we'll just invoke that again.

#+begin_src emacs-lisp
(defun TT/reload-emacs-configuration ()
  (interactive)
  (load-file "~/.emacs.d/init.el"))
#+end_src


** Screenshots
In Emacs 27.1+ you can use Cairo to take an SVG screenshot of Emacs.

#+begin_src emacs-lisp
(defun screenshot-svg ()
  "Save a screenshot of the current frame as an SVG image.
Saves to a temp file and puts the filename in the kill ring."
  (interactive)
  (let* ((filename (make-temp-file "Emacs" nil ".svg"))
         (data (x-export-frames nil 'svg)))
    (with-temp-file filename
      (insert data))
    (kill-new filename)
    (message filename)))
#+end_src


* Global Keybinding Overrides
This section contains my global keybinding overrides. There are key-bindings defined elsewhere in my configuration,
typically within the context they'll be used in. This isn't a hard rule, but is what I lean towards.

#+begin_src emacs-lisp
;; Buffer Key Bindings
(global-set-key (kbd "S-w") 'kill-this-buffer)
(global-set-key (kbd "C-S-<left>") 'shrink-window-horizontally)
(global-set-key (kbd "C-S-<right>") 'enlarge-window-horizontally)
(global-set-key (kbd "C-S-<down>") 'shrink-window)
(global-set-key (kbd "C-S-<up>") 'enlarge-window)
(global-set-key (kbd "C-x |") 'window-toggle-split-direction)
(global-set-key (kbd "C-c o") 'switch-to-minibuffer)
(global-set-key (kbd "<f8>") 'flyspell-buffer)
(global-set-key (kbd "C-c s") 'flyspell-learn-word-at-point)

;; Misc Keybindings
(global-set-key (kbd "C-c 1") 'open-config-file)
(global-set-key (kbd "C-x #") 'comment-or-uncomment-region)
(global-set-key (kbd "C-c d") 'duplicate-current-line-or-region)
;;(global-set-key (kbd "M-.") 'find-tag-other-window)

;; Modal Key Bindings
(add-hook 'cperl-mode-hook
          (lambda ()
            (local-set-key (kbd "C-h f") 'cperl-perldoc)))
#+end_src

** Disable Problematic Bindings
Some keybindings are just the bane of my existence. While many are undo-able, some cause more trouble that outweighs the
value of having the binding.

#+begin_src emacs-lisp
;; Kill the bane of my fat-fingers
(global-unset-key (kbd "C-z"))
(global-unset-key (kbd "C-x C-z"))
#+end_src


** Setup Org Global Interactions
I want to be able to start interacting with org-mode regardless of what buffer I'm presently in.

#+begin_src emacs-lisp
;; Org-Mode Keybindings
(global-set-key (kbd "C-c a") 'org-agenda)
(global-set-key (kbd "C-c c") 'org-capture)
(global-set-key (kbd "C-c l") 'org-store-link)
(global-set-key (kbd "C-c i") 'org-capture-inbox)
#+end_src


** Enable Full Keyboard Number Pad
Unfortunately I've found Emacs doesn't natively support full size keyboards, however this allows us to get the numpad
working.

#+begin_src emacs-lisp
;; Numpad Key Bindings
(global-set-key "\eOp" "0")
(global-set-key "\eOq" "1")
(global-set-key "\eOr" "2")
(global-set-key "\eOs" "3")
(global-set-key "\eOt" "4")
(global-set-key "\eOu" "5")
(global-set-key "\eOv" "6")
(global-set-key "\eOw" "7")
(global-set-key "\eOx" "8")
(global-set-key "\eOy" "9")
(global-set-key "\eOl" "+")
(global-set-key "\eOn" ".")
#+end_src


* Completing Configuration
This section contains the last moment configurations that wrap up my personal customization and Emacs load. Here we'll
kill mode-line clutter and start up the Emacs server.

#+begin_src emacs-lisp
(delight '((auto-fill-function nil t)
           (eldoc-mode nil eldoc)
           (org-indent-mode nil org-indent)
           (which-function-mode nil which-func)))

;; Make it so I can recover old sessions after close or reboot
(desktop-save-mode 1)

;; Load configuration files local to employer
;;(org-babel-load-file "~/.emacs.d/employer.org")

;;Finally, let's load a theme and bring some style to Emacs.
(use-package kaolin-themes
  :demand t
  :init
  (load-theme 'kaolin-eclipse t))

;; Start the Emacs server
(require 'server)
(unless (server-running-p)
  (defvar server-name (concat "server"(number-to-string (emacs-pid))))
  (ignore-errors (server-start))

  ;; Set the environment variables for *shell*.
  (setenv "EDITOR" (concat "~/usr/local/bin/emacsclient -s " server-name)))

;;(put 'narrow-to-region 'disabled nil)
(provide 'configuration)
;;; configuration.el ends here

#+end_src


* Future Work

** Questions to Answer
- [ ] When to use =:custom= vs =:config= and others in =use-package=?


** TODO Configuration Reading [0/8]
That's mostly it folks. Configuration is done, the rest are future works. This section collects other articles or
configurations I've stumbled across and bookmarked for eventual reading.

Research Topics or Reading Material:
- [ ] Refiling
- [ ] =bbdb=
- [ ] =epg=
- [ ] =fzf= - fuzzy file finding
- [ ] Inspiration Exploration (conf reading)
  - [ ] https://github.com/hungptit/tools and integration w/ Emacs
  - [ ] https://gitlab.com/jaor/geiser
- [ ] email
  - [ ] https://github.com/rougier/emacs-gtd#working-with-mail
- [ ] [[https://olmon.gitlab.io/org-themes/][org-themes]]
- [ ] [[https://github.com/rougier/notebook-mode][notebook-mode]]
