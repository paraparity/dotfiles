#+TITLE: Paraparity's Literate Emacs Configuration
#+PROPERTY: header-args :tangle yes

* Overview
I've maintained my Emacs configuration in a number of styles across the years, each having its own strengths and
weaknesses. I've even declared configuration bankruptcy a few times. Presently I'm experimenting with a literate
configuration where I hope to better capture the intent and reasons for my configuration settings. My hope is that this
improves my experience maintaining my configuration, and that it also helps others understand what these configs do.

I invite your feedback openly. Welcome aboard my ship of Theseus.

** House Keeping

*** Variable Naming Convention
As is common among Emacsers, I've opted to adopt a naming scheme that identifies personal contributions and adds a bit
of individual flare. Considering the name I go by is =Paraparity=, you'll notice a number of names prefixed with
=TT/=. This represents a so-called =pair of T's= playing off of the =parity= portion of my handle.


*** Add Some Output Commentary
When tangled, all of these source blocks become an =.el= file. I'd still like that to be more friendly than just a
bunch of configuration code, so let's keep my old =init.el= header around.

#+begin_src emacs-lisp
;;; configuration.el --- paraparity's Emacs configuration file
;;
;;; Commentary:
;; Customized startup for Emacs
;;
;;; Code:

;; Eternally grateful to have gleaned lessons from:
;;   http://doc.norang.ca/org-mode.html
;;   http://members.optusnet.com.au/~charles57/GTD/orgmode.html
;;   http://pages.sachachua.com/.emacs.d/Sacha.html
;;   https://www.labri.fr/perso/nrougier/GTD/index.html
;;   https://github.com/purcell/emacs.d
;;   https://github.com/howardabrams/dot-files
;;   https://github.com/skeeto/.emacs.d
#+end_src


* General Settings

** Where Files Live
Let's set up where to load configurations from, where to store saves, and give files homes.

*** Setup Load Paths
Emacs only includes packages under the =user-emacs-directory= (default =~/.emacs.d/elpa/=), so if we want to load
anything else up we'll need to tell Emacs where to look.

#+begin_src emacs-lisp
(add-to-list 'load-path "~/.emacs.d/elisp/")
#+end_src

Load my machine local custom libraries directly, if they exist. My elfeed configuration is machine local for now, as my
work and personal machines all represent different contexts where I pay attention to different things.

#+begin_src emacs-lisp
(if (file-readable-p "~/.emacs.d/elisp/elfeed-conf.el")
    (load-library "elfeed-conf"))
#+end_src


*** Offload Custom File
I manage my custom literate configuration, but sometimes use Emacs easy configuration to tweak settings. Until I know I
want to keep these tweaks, I'll give them their own home.

#+begin_src emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(when (file-exists-p custom-file)
  (load custom-file 'noerror))
#+end_src


*** Separate File Backups and Auto Save
Emacs can get a bit aggressive with file backups and auto-saves. I dislike how it can pollute my directories and
especially collaborative projects with tilde files (e.g: =myfile.txt~=). Usually things like =.gitignore= are sufficient
to insulate others from these, but I'd prefer not to see them myself.

#+begin_src emacs-lisp
;; File Backup Management
(setq backup-by-copying t
      backup-directory-alist `(("." . "~/saves"))
      delete-old-versions t
      kept-new-versions 6
      kept-old-versions 2
      version-control t)

;; Autosave File Management
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))
#+end_src


*** Easy Config Editing
Let's make it a only take a key-chord to pull up my literate configuration.

#+begin_src emacs-lisp
(defun TT/locate-literate-config ()
  "Locate and load my literate configuration file."
  (interactive)
  (find-file "~/.emacs.d/configuration.org"))

(global-set-key (kbd "C-c I") 'TT/locate-literate-config)
#+end_src


** Encoding Systems
Pretty much just set the coding system to UTF-8. Also enable the Japanese language environment to support study.

#+begin_src emacs-lisp
(prefer-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)

(set-language-environment "japanese")
#+end_src


** Emacs Appearance
Who doesn't love customizing the look and feel of their workspace?

*** Kill Unnecessary Default Clutter
Give me back my screen real estate. I don't need your newfangled and fancy GUI features, they just get in the way of
more lines of sweet, sweet text. I also find the visual bell annoying, so let's take that out.

#+begin_src emacs-lisp
(setq inhibit-startup-screen t
      inhibit-startup-message t
      initial-scratch-message nil)

(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)

(setq ring-bell-function 'ignore)
#+end_src


*** Style Our Frame
Let's give Emacs a name, I think Emacs sounds nice.

#+begin_src emacs-lisp
(setq frame-title-format "Emacs")
#+end_src

Let's make sure our buffers have unique names. If we were to open a file of the same name, but a different location we
only need them to be a little unique, not full file path or even relative file path unique.

#+begin_src emacs-lisp
(require 'uniquify)
#+end_src

Let's get some more screen real estate by using a small, code friendly font.

#+begin_src emacs-lisp
(set-frame-font "monospace-10")
#+end_src

Let's keep track of time in the mode-line.

#+begin_src emacs-lisp
(display-time-mode 1)
#+end_src

Let's also keep track of which column we're on in the buffer.

#+begin_src emacs-lisp
(setq column-number-mode t)
#+end_src

Let's add some transparency. Despite how powerful it is, I don't use Emacs for everything and this lets me read
whatever I have Emacs opened over. This can also let me see my desktop background which can be really cozy.

#+begin_src emacs-lisp
(set-frame-parameter (selected-frame) 'alpha '(92 . 90))
(add-to-list 'default-frame-alist '(alpha . (92 . 90)))
#+end_src


*** Hunt Trailing White-space, Sometimes
I personally disdain trailing white-space, but also dislike how visually congested =whitespace-mode= can be
sometimes. As such, lets make things toggle-able so I can inspect white-space on demand with only a key chord. Also,
lets give ourselves a nuclear option for stripping trailing white-space.

#+begin_src emacs-lisp
(defun TT/toggle-trailing-whitespace ()
  "Toggle 'show-trailing-whitespace' between t and nil."
  (interactive)
  (setq show-trailing-whitespace (not show-trailing-whitespace)))

(global-set-key (kbd "C-c w m") 'whitespace-mode)
(global-set-key (kbd "C-c w t") 'TT/toggle-trailing-whitespace)
(global-set-key (kbd "<f5>") 'delete-trailing-whitespace)
#+end_src

Enable final newline in all files. It's pretty common in software projects, and it's just a habit by now, I'll include
it everywhere until I find somewhere that bites me because of it.

#+begin_src emacs-lisp
(setq require-final-newline t)
#+end_src


** Various Emacs Settings
Since I don't use directory local variables for Emacs very much if at all, and considering they could load arbitrary
emacs-lisp, potentially without my knowing, lets prevent that from happening.

#+begin_src emacs-lisp
(setq enable-local-eval nil
      enable-local-variables nil)
#+end_src

Enable quick Y/N prompts.

#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

At one point I had some slowness with cursor movement and scrolling. I forget why at this point, but I stumbled upon
some answer that said disable this, and I've never looked back since.

#+begin_src emacs-lisp
(setq auto-window-vscroll nil)
#+end_src

This probably deserves it's own section and some more configuration, but for now here's a minimal GPG setup.

#+begin_src emacs-lisp
(defvar epg-gpg-program "gpg2")

;; Auth
(defvar auth-sources '((:source "~/.emacs.d/secrets/.authinfo.gpg")) "Auth info source location.")
#+end_src


** Key Frequency Tracking
This helps identify frequently used commands which could be bound for faster use.

#+begin_src emacs-lisp
(use-package keyfreq
  :config
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1))
#+end_src


* Emacs Interactions
This section contains customizations which focus on Emacs navigation and interaction.

** Improve Buffer Interactions
Let's keep track of the currently focused line, always, everywhere.

#+begin_src emacs-lisp
(global-hl-line-mode t)
#+end_src

Let's make it easy to see current block parentheses, given they're both on screen.

#+begin_src emacs-lisp
(show-paren-mode 1)
#+end_src

Let's display which-function-mode, and do so in the header line instead of mode line. This echoes the current org
heading or function to the topmost part of a buffer which helps me keep track of what context my cursor is in.

#+begin_src emacs-lisp
(which-function-mode)
(defvar which-func-header-line-format)

(setq mode-line-misc-info
      (delete
       (assoc 'which-func-mode
              mode-line-misc-info) mode-line-misc-info)
      which-func-header-line-format '(which-func-mode ("" which-func-format)))

(defadvice which-func-ff-hook (after header-line activate)
  "Hook for which-func formatting."
  (when which-func-mode
    (setq mode-line-misc-info
          (delete
           (assoc 'which-func-mode
                  mode-line-misc-info) mode-line-misc-info)
          header-line-format which-func-header-line-format)))
#+end_src


** Auto Revert Buffers
In the event something has changed on the system, I want to pull in the updated files. =Magit= has been good about doing
this for version controlled files, however I've often noticed some buffer diffs for other files. =autorevert= should
help keep things in sync.

#+begin_src emacs-lisp
(use-package autorevert
   :ensure nil
   :diminish
   :init (global-auto-revert-mode))
#+end_src


** Multiple Cursors
Sometimes one cursor isn't enough. This package lets me spin up multiple cursors across lines or matching patterns which
can lead to some pretty impressive editing and refactoring feats.

#+begin_src emacs-lisp
(use-package multiple-cursors
  :ensure t
  :bind (;; Note that recomended 'C->' and 'C-<' are not characters in the shell.
         ;; Thus I use their lowercase alternatives
         ("C-c ."   . mc/mark-next-like-this)
         ("C-c ,"   . mc/mark-previous-like-this)
         ("C-c /"   . mc/mark-all-like-this)
         ("C-c m m" . mc/mark-all-like-this-dwim)
         ("C-c m a" . mc/edit-beginnings-of-lines)
         ("C-c m e" . mc/edit-ends-of-lines)
         ("C-c m s" . mc/mark-sgml-tag-pair)
         ("C-c m l" . mc/edit-lines)))
#+end_src


** =helm=
=helm= gives us incremental completions and narrowing capabilities that really help find what you're looking for.

#+begin_src emacs-lisp
(use-package helm
  :diminish helm-mode
  :init (progn
          (require 'helm-config)
          (helm-mode))
  :bind (("C-c h"   . helm-command-prefix)
         ("M-x"     . helm-M-x)
         ("M-y"     . helm-show-kill-ring)
         ("C-x b"   . helm-mini)
         ("C-c h a" . helm-apropos)
         ("C-c h f" . helm-find-files)
         ("C-c h o" . helm-occur)
         ("C-c h m" . helm-man-woman))
  :config
  (require 'helm-command)
  (require 'helm-for-files)
  (require 'helm-imenu)
  (require 'helm-semantic)
  (require 'helm-misc)
  (setq helm-split-window-inside-p      t
        helm-M-x-fuzzy-match            t
        helm-buffers-fuzzy-matching     t
        helm-recentf-fuzzy-match        t
        helm-semantic-fuzzy-match       t
        helm-imenu-fuzzy-match          t
        helm-apropos-fuzzy-match        t
        helm-candidate-number-limit   100
        helm-autoresize-max-height     20
        helm-autoresize-min-height      0)
  (add-to-list 'helm-sources-using-default-as-input 'heml-source-man-pages)
  (helm-autoresize-mode t))
#+end_src


** Buffer Folding with =origami=
=Origami= minor-mode enables text folding across Emacs. It's pretty useful, though sometimes slow and sometimes
buggy. With =origami-reset= you can always unfold everything and reset the file, which has always been enough to ignore
some of the hiccups.

I find this very helpful in collapsing functions in source code and narrowing my focus to the important parts of a file.

#+begin_src emacs-lisp
(use-package origami
  :bind (("C-<tab>" . origami-recursively-toggle-node)
         ("C-c u"   . origami-open-all-nodes)
         ("C-c f"   . origami-close-all-nodes)
         ("C-c n"   . origami-show-only-node)
         ("C-c r"   . origami-reset))
  :config
  (global-origami-mode t))

#+end_src


** Text Expansion with =abbrev=
=Abbrev= triggers expansion on pressing the space bar after your word, which is incredibly useful for stream of
conscious text expansion. I use this mainly to expand acronyms and abbreviations, so I can lazily type and still create
readable text for those not yet familiar with those short-strings. However, this is also extremely useful for creating
shortcuts for words I type often.

#+begin_src emacs-lisp
(use-package abbrev
  :ensure nil
  :diminish abbrev-mode
  :config
  (setq abbrev-file-name
        "~/.emacs.d/abbrev_defs")
  (setq save-abbrevs t)
  (if (file-exists-p abbrev-file-name)
      (quietly-read-abbrev-file)))

;; Add Abbrev-Mode Hooks
(dolist (hook '(erc-mode-hook
                emacs-lisp-mode-hook
                text-mode-hook
                org-mode-hook))
  (add-hook hook (lambda () (abbrev-mode 1))))
;; (setq default-abbrev-mode t) ;; Or, default on everywhere
#+end_src


** Templating with =yasnippet=
Both for programming and regular editing I have a bunch of snippets for text expansion. It doesn't always seem suitable
for me to use =abbrev=, especially for large templates, but that's more of a personal choice than a "can it be done"
thing.

So, for anything more than abbreviation expansion or word shortcut expansions I use =yasnippet= to tab expand and
interactively fill out templates.

#+begin_src emacs-lisp
(use-package yasnippet
  :diminish yas-minor-mode
  :diminish yas-global-mode
  :bind (("C-c y r" . yas-reload-all)
         ("C-c y n" . yas-new-snippet)
         ("C-c y x" . yas-exit-snippet)
         ("C-c y d" . yas-describe-tables)
         ("C-c y v" . yas-visit-snippet-file)
         ("C-c y l" . yas-load-snippet-buffer-and-close))
  :config
  (setq yas-verbosity 1)
  (yas-global-mode 1))
#+end_src


** TODO Remote Interactions with =tramp=
Emacs comes packaged with a really cool utility I'm desperately under-utilizing. More work to be done here still.

Let's change where Tramp saves things, and use SSH as our default method.

#+begin_src emacs-lisp
(use-package tramp)

(set-default 'tramp-auto-save-directory "~/.saves/tramp/")
(setq tramp-default-method "ssh")

;; TODO: if windows: use PuTTy Plink; if *nix: use ssh
#+end_src


* =org-mode= Configuration
=org-mode= is probably my biggest anchor to Emacs. I've tried org-like plugins for other editors and IDEs, but nothing
compares to the real thing.

Let's load all the things! Well, all the things I use anyway.

#+begin_src emacs-lisp
(use-package org)
(use-package ob-C :ensure nil)
(use-package ob-ditaa :ensure nil)
(use-package ob-dot :ensure nil)
(use-package ob-js :ensure nil)
(use-package ob-perl :ensure nil)
(use-package ob-plantuml :ensure nil)
(use-package ob-sql-mode)
(use-package org-agenda :ensure nil)
(use-package org-capture :ensure nil)
(use-package org-clock :ensure nil)
(use-package ox :ensure nil)
(use-package ox-ascii :ensure nil)
(use-package ox-asciidoc)
(use-package ox-html :ensure nil)
(use-package ox-latex :ensure nil)
(use-package ox-pandoc)
(use-package ox-slimhtml)

;; This wasn't loading well via use-package...
(require 'org-tempo)

(setq org-modules
      '((org-bbdb org-bibtex org-docview org-eww org-gnus org-habit org-info org-irc org-mhe org-rmail org-tempo org-w3m)))
#+end_src

Let's also update a few general settings and behavior.

#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'turn-on-auto-fill)
(add-hook 'org-mode-hook
      '(lambda () (origami-mode nil)))

(setq org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-src-preserve-indentation nil
      org-startup-indented t ; will this end my indentation woes?
      org-edit-src-content-indentation 0
      org-ellipsis " [+]")

(custom-set-faces '(org-ellipsis ((t (:foreground "gray40" :underline nil)))))
#+end_src

** Org Structure
This section sets up my org-mode file structure. This involves the root of my org directory, the location of my
agenda files, and the like.

#+begin_src emacs-lisp
(defvar org-directory           "~/org"                                         "Root 'org-mode' directory.")
(defvar TT/org-agenda-dir       (concat org-directory "/agendas")               "Top level org directory for Getting Things Done (GTD) organizer files.")
(defvar TT/org-calendar         (concat TT/org-agenda-dir "/calendar.org")      "Calendar for scheduled actionables.")
(defvar TT/org-habits           (concat TT/org-agenda-dir "/habits.org")        "Habits for periodic todos.")
(defvar TT/org-inbox            (concat TT/org-agenda-dir "/inbox.org")         "The collection bin for everything to be refiled.")
(defvar TT/org-incubate-dir     (concat TT/org-agenda-dir "/incubate")          "Categories of inactionable things to incubate.")
(defvar TT/org-emacs-maybe      (concat TT/org-incubate-dir "/emacs-maybe.org") "Someday agenda for Emacs related things.")
(defvar TT/org-ideas            (concat TT/org-incubate-dir "/ideas.org")       "Someday agenda to capture general or 'idea?' ideas.")
(defvar TT/org-projects         (concat TT/org-incubate-dir "/projects.org")    "Someday agenda for project ideas.")
(defvar TT/org-someday          (concat TT/org-incubate-dir "/someday.org")     "Someday agenda for things I may want to revisit.")
(defvar TT/org-travel           (concat TT/org-incubate-dir "/travel.org")      "Someday agenda for travel related things.")
(defvar TT/org-learning         (concat TT/org-agenda-dir "/learning.org")      "Agenda for structured learning.")
(defvar TT/org-manager          (concat TT/org-agenda-dir "/manager.org")       "Actionables and captures for 1:1s with my manager.")
(defvar TT/org-organizer        (concat TT/org-agenda-dir "/organizer.org")     "Core organizer tracking prioritized actionable work.")
(defvar TT/org-retrospective    (concat TT/org-agenda-dir "/retro.org")         "Capture target for retro related info or actionables.")
(defvar TT/org-review           (concat TT/org-agenda-dir "/review.org")        "Reference on and journal for reflection.")
(defvar TT/org-tickler          (concat TT/org-agenda-dir "/tickler.org")       "Time relevant reminders for 'decide to do later' items.")
(defvar TT/org-waiting          (concat TT/org-agenda-dir "/waiting.org")       "Delegated or blocked items awaiting external action.")
(defvar TT/org-blog             (concat org-directory "/blog")                  "Top level org directory for blog posts.")
(defvar TT/org-brain-dir        (concat org-directory "/brain")                 "Top level org directory for 'org-brain' reference material.")
(defvar TT/org-checklist-dir    (concat org-directory "/checklists")            "Top level org directory for action oriented reference; do/certify.")
(defvar TT/org-commonplace-dir  (concat org-directory "/commonplace")           "Top level org directory for 'commonplace book' material.")
(defvar TT/org-journal-dir      (concat org-directory "/journal")               "Top level org directory for journal entries.")
(defvar TT/org-ledger-dir       (concat org-directory "/ledger")                "Top level org directory for accounting/budgeting ledgers.")

(defvar org-default-notes-file TT/org-inbox)
#+end_src


** Org Agenda
With org-mode to-do items and tags configured, we can start unleashing the real power behind org-mode and configure
our agendas.

Org-mode agendas pull from a list of files which I have mostly tucked away under the =agendas= sub-directory within
my =org-directory=. The structure of these files is mostly informed by the Getting Things Done framework.

#+begin_src emacs-lisp
;; Agenda Files:
(setq org-agenda-files
      (delq nil
            (mapcar (lambda (x) (and x (file-exists-p x) x))
                    `("~/org/agendas/calendar.org"
                      "~/org/agendas/habits.org"
                      "~/org/agendas/inbox.org"
                      "~/org/agendas/organizer.org"
                      "~/org/agendas/tickler.org"
                      "~/org/agendas/waiting.org"))))
#+end_src

Let's also modify some other agenda settings.

#+begin_src emacs-lisp
(setq org-agenda-skip-deadline-if-done t
      org-agenda-skip-scheduled-if-done t
      org-agenda-skip-timestamp-if-deadline-is-shown t
      org-agenda-show-future-repeats t
      org-agenda-dim-blocked-tasks nil ; dimming can slow the agenda  down - a filter could show blocked tasks better
      org-agenda-inhibit-startup t ; speedup agenda loading by ignoring startup options
      org-tags-column -128
      org-agenda-todo-keyword-format "%-12s"
      org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
#+end_src

*** Agenda Helpers
    This section contains some helpful functions for working with agenda items.

    A while back I stumbled across Aaron Bieber's blog which has some really helpful posts about Emacs. Particularly of
    interest here is this post: [[https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html][An Agenda for Life with org-mode]]. From it, I've lifted the following helpers.

    #+begin_src emacs-lisp
    (defun air/org-skip-subtree-if-priority (priority)
      "Skip an agenda subtree if it has a priority of PRIORITY.
        PRIORITY may be one of the characters ?A, ?B, or ?C."
      (let ((subtree-end (save-excursion (org-end-of-subtree t)))
            (pri-value (* 1000 (- org-lowest-priority priority)))
            (pri-current (org-get-priority (thing-at-point 'line t))))
        (if (= pri-value pri-current)
            subtree-end
          nil)))

    (defun air/org-skip-subtree-if-habit ()
      "Skip an agenda entry if it has a STYLE property equal to \"habit\"."
      (let ((subtree-end (save-excursion (org-end-of-subtree t))))
        (if (string= (org-entry-get nil "STYLE") "habit")
            subtree-end
          nil)))
    #+end_src


** Org Agenda Commands
Agenda commands are the powerhouse behind org-mode and agendas. These allow you to query across your agenda files and
surface reports of varying complexity. It's a great way to get exactly the thing you want, with only a few keystrokes.

Agenda commands have the following form:
#+begin_example
(setq org-agenda-custom-commands
      '(
        ;; (1 key) (2 description (optional)) (3 type of search) (4 search term)
        ("c" "Desk Work" tags-todo "computer"
         ((org-agenda-files '("~/org/widgets.org" "~/org/clients.org")) ;; (5 settings (optional))
          (org-agenda-sorting-strategy '(priority-up effort-down)))
         ("~/computer.html"))                                           ;; (6 export files (optional))
        ;; ... other commands
        ))
#+end_example

For further reference see the [[https://orgmode.org/worg/org-tutorials/advanced-searching.html][Worg Advanced Searching Tutorial]] or the [[https://orgmode.org/manual/Custom-Agenda-Views.html#Custom-agenda-views][Custom Agenda Views Manual]].

I define these by initializing the commands list with an a weekly preview and append additional templates after. I do
this so I can split the declarations up and describe them better in my literate configuration. I'll initialize a simple
weekly review that shows a span of seven days highlighting stuck projects, open projects, and things awaiting something
to happen.

#+begin_src emacs-lisp
(defvar TT/org-agenda-custom-commands (list) '())

(setq TT/org-agenda-custom-commands
      '(("w" "Weekly Review"
         ((agenda ""
                  ((org-agenda-span 7)))
          (stuck "")
          (tags "PROJECT")
          (todo "WAITING")))))
#+end_src

Now we can append new search filters to this initialized list which we'll use to initialize the
=org-agenda-custom-commands= variable after.

*** TODO GTD Views
I like to use David Allen's Getting Things Done (GTD) framework for inspiration to my Emacs =org-mode= agenda
management. Here let's define several GTD views for my agenda contents.

#+begin_src emacs-lisp
(setcdr (last TT/org-agenda-custom-commands)
        '(("g" . "GTD Views")
          ("gi" "Inbox"
           ((alltodo ""
                     ((org-agenda-files '(TT/org-inbox))
                      (org-agenda-overriding-header "Items in my Inbox")))))
          ("gu" "Unscheduled TODOs"
           ((todo ""
                  ((org-agenda-overriding-header "Unscheduled TODOs:")
                   (org-agenda-sorting-strategy '(priority-down effort-up tag-up))
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'timestamp 'todo 'done))))))
          ("gn" "Next Actions"
           ((todo "NEXT"
                  ((org-agenda-overriding-header "Next Actions:")
                   (org-agenda-sorting-strategy '(priority-down effort-up tag-up))))))
          ("gw" "Delegated or Waiting-On"
           ((todo "WAITING"
                  ((org-agenda-overriding-header "Awaiting Response or Action:")))
            (todo "DELEGATED"
                  ((org-agenda-overriding-header "Pending Delegate Completion:")))))
          ("gd" "Daily agenda and all TODOs"
           ((tags "PRIORITY=\"A\""
                  ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                   (org-agenda-overriding-header "High-Priority Unfinished Tasks:")))
            (agenda ""
                    ((org-agenda-span 1)))
            (alltodo ""
                     ((org-agenda-skip-function
                       '(or (air/org-skip-subtree-if-habit)
                            (air/org-skip-subtree-if-priority ?A)
                            (org-agenda-skip-if nil '(scheduled deadline))))
                      (org-agenda-overriding-header "All Normal Priority Tasks:"))))
           ((org-agenda-compact-blocks t)))))
#+end_src


*** GTD Contexts
I use =org-mode= tags starting with an '@' symbol to designate a context. A context is a physical space, headspace, or
tool that a set of work is associated with.

These aren't too fancy, namely a bunch of searches for context tags. I reuse the binding from the quick tag for
consistency. I want to narrow in on unfinished work in a certain context so I can batch tasks in a context together when
I'm working in that context.

#+begin_src emacs-lisp
(setcdr (last TT/org-agenda-custom-commands)
        '(("@" . "Context Filters")
          ("@a" "Administrative Work"
           ((tags "@administrative"
                  ((org-agenda-overriding-header "Open Administrative Tasks:")
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))))))
          ("@c" "Career Work"
           ((tags "@career"
                  ((org-agenda-overriding-header "Open Career Tasks:")
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))))))
          ("@m" "Communication Work"
           ((tags "@communication"
                  ((org-agenda-overriding-header "Open Communications Tasks:")
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))))))
          ("@f" "Finance Work"
           ((tags "@finances"
                  ((org-agenda-overriding-header "Open Financial Tasks:")
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))))))
          ("@g" "Guild and Community of Practice Work"
           ((tags "@guild"
                  ((org-agenda-overriding-header "Open Guild Tasks:")
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))))))
          ("@h" "Health and Wellness Work"
           ((tags "@"
                  ((org-agenda-overriding-header "Open Health and Wellness Tasks:")
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))))))
          ("@i" "Hiring Work"
           ((tags "@hiring"
                  ((org-agenda-overriding-header "Open Hiring Tasks:")
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))))))
          ("@H" "Home Work"
           ((tags "@home"
                  ((org-agenda-overriding-header "Open Home Tasks:")
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))))))
          ("@l" "Learning Agenda"
           ((tags "@learn"
                  ((org-agenda-overriding-header "Open Learning Agenda Items:")
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))))))
          ("@R" "Review Work"
           ((tags "@review"
                  ((org-agenda-overriding-header "Open Items for Review:")
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))))))
          ("@d" "Scheduling and Calendar Work"
           ((tags "@scheduling"
                  ((org-agenda-overriding-header "Open Scheduling and Calendar Tasks:")
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))))))
          ("@s" "Sprint Work"
           ((tags "@sprint"
                  ((org-agenda-overriding-header "Open Sprint Tasks:")
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))))))
          ("@t" "Travel and Planning Work"
           ((tags "@travel"
                  ((org-agenda-overriding-header "Open Travel Tasks:")
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))))))
          ("@w" "Workstation Work"
           ((tags "@workstation"
                  ((org-agenda-overriding-header "Open Workstation Tasks:")
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))))))))
#+end_src


*** Calendar View
#+begin_src emacs-lisp
(setcdr (last TT/org-agenda-custom-commands)
        '(("c" "Calendar"
           ((agenda ""
                    ((org-agenda-span 7)
                     (org-agenda-start-on-weekday 0)
                     (org-agenda-time-grid-nil)
                     (org-agenda-repeating-timestamp-show-all t)
                     (org-agenda-entry-types '(:timestamp :sexp))))))))
#+end_src


*** TODO Sprint Views
Sprint views are intended to highlight sprint work as well as to surface todos that were completed in the last sprint
interval. I don't care to get the interval exactly right, instead I'll just do a two week lookback for completed work
that is most useful on an end of sprint day.

#+begin_src emacs-lisp
(setcdr (last TT/org-agenda-custom-commands)
        '(("v" "Sprint and Retro Views")
          ("vc" "Retro Completed Work"
           ((todo "DONE"
                  ((org-agenda-span "-14d")
                   (org-agenda-start-on-weekday nil)
                   (org-agenda-sorting-strategy '(tag-up priority-down))
                   (org-agenda-todo-keyword-format "")
                   (org-agenda-overriding-header "Completed Work")))
            (todo "COMPLETED"
                  ((org-agenda-span "-14d")
                   (org-agenda-start-on-weekday nil)
                   (org-agenda-todo-keyword-format "")
                   (org-agenda-overriding-header "Attended Meetings")))))))
#+end_src


*** Daily Agenda
#+begin_src emacs-lisp
(setcdr (last TT/org-agenda-custom-commands)
        '(("d" "Daily agenda and all TODOs"
           ((tags "PRIORITY=\"A\""
                  ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                   (org-agenda-overriding-header "High-Priority Unfinished Tasks:")))
            (agenda ""
                    ((org-agenda-span 1)))
            (alltodo ""
                     ((org-agenda-skip-function
                       '(or (air/org-skip-subtree-if-habit)
                            (air/org-skip-subtree-if-priority ?A)
                            (org-agenda-skip-if nil '(scheduled deadline))))
                      (org-agenda-overriding-header "All Normal Priority Tasks:"))))
           ((org-agenda-compact-blocks t)))))
#+end_src


*** Daily Actions
#+begin_src emacs-lisp
(setcdr (last TT/org-agenda-custom-commands)
        '(("D" "Daily Action List"
           ((agenda ""
                    ((org-agenda-span 1)
                     (org-agenda-sorting-strategy
                      '((agenda time-up priority-down tag-up)))
                     (org-deadline-warning-ndays 0)))))))
#+end_src


*** Priority Matrix Commands
#+begin_src emacs-lisp
(setcdr (last TT/org-agenda-custom-commands)
        '(("1" "Q1" tags-todo "+IMPORTANT+URGENT")
          ("2" "Q2" tags-todo "+IMPORTANT-URGENT")
          ("3" "Q3" tags-todo "-IMPORTANT+URGENT")
          ("4" "Q4" tags-todo "-IMPORTANT-URGENT")))
#+end_src


*** Deadline Review
#+begin_src emacs-lisp
(setcdr (last TT/org-agenda-custom-commands)
        '(("x" "With deadline columns"
           ((alltodo ""
                     ((org-agenda-overriding-columns-format "%20ITEM %DEADLINE")
                      (org-agenda-view-columns-initially t)))))
          ("X" "Upcoming Deadlines"
           ((agenda ""
                    ((org-agenda-entry-types '(:deadline))
                     (org-agenda-span 1)
                     (org-deadline-warning-days 60)
                     (org-agenda-time-grid nil)))))))
#+end_src


*** Archive Queries
#+begin_src emacs-lisp
(setcdr (last TT/org-agenda-custom-commands)
        '(("Q" . "Custom Queries")
          ("Qa" "Archive Search"
           ((search ""
                    ((org-agenda-files
                      (file-expand-wildcards "~/org/archive/*.org"))))))
          ("QA" "Archive Tags Search"
           ((org-tags-view ""
                           ((org-agenda-files
                             (file-expand-wildcards "~/org/archive/*.org"))))))))
#+end_src


*** TODO Misc Commands
A few of these commands that I'm workshopping didn't quite make sense elsewhere. Still not sure what I want to do with
them yet.

#+begin_src emacs-lisp
(setcdr (last TT/org-agenda-custom-commands)
        '(("y" "Someday Maybe"
           ((todo "MAYBE"
                  ((org-agenda-files '("~/org/maybe.org"))))))
          ("r" "Review"
           ((todo "REVIEW"
                  ((org-agenda-files '("~/org/review.org"))))))))
#+end_src


*** Setting Agenda Commands
Lastly I set =org-agenda-custom-commands= to the value of the list I've built.

#+begin_src emacs-lisp
(setq org-agenda-custom-commands TT/org-agenda-custom-commands)
#+end_src


** Org To-Do
Org todos help keep track of work I plan to do and how I engaged with completing that work. Let's get a few general
things set up here.

#+begin_src emacs-lisp
(setq org-treat-insert-todo-heading-as-state-change t)
#+end_src


*** Keywords
Org-mode has a set of configurable keywords, both sequenced and typed, which can be added to headlines and cycled
through to track an arbitrary workflow you define. This is where I define my keywords.

The default org-mode sequence is as follows:
#+begin_example
,-> (unmarked) -> TODO -> DONE --.
'--------------------------------'
#+end_example

However, that's pretty simple and I have something else in mind.

#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO(t)" "NEXT(n)" "STARTED(s)" "WAITING(w@)" "|" "DONE(d)" "DROP(x@)")
        (sequence "MEETING(m)" "APPOINTMENT(a)" "|" "FINISHED(f)" "CANCELLED(l)")
        (sequence "DELEGATED(g@)"               "|" "COMPLETED(p)")
        (sequence "REVIEW(r)" "REWORK(k@)"      "|" "REVIEWED(v)")
        (sequence "OPEN(o)"                     "|" "CLOSED(c@)")))

(setq org-todo-keyword-faces
      '(("STARTED" . "cyan")
        ("MAYBE"   . "purple")
        ("WAITING" . (:foreground "yellow" :weight bold))
        ("CANCELLED" . "DimGray")
        ("DROP"    . "DimGray")))
#+end_src


*** Tags
Org-mode files and headlines can be tagged to enable searching and correlating information across files and directories.

To support my Emacs implementation of Getting Things Done (GTD), I have a set of tags I use to denote tasks, projects,
and contexts. For now this is enough, though I think there's still more improvement to make here, especially when it
comes to searching behavior.

My tags come in three flavors:
1. '@context' - indicates physical location, headspace, or tool these tasks are associated with, or some other
   context in which to act on them in
2. 'TYPE' - indicates whether the item is a project or task, if it's next up, or if it has some other classification
3. 'info' - represents informational tags for categorization and search

I try to give each tag a mnemonic hotkey and resolve collisions with capitalization or by choosing another key within
the word, but it's an imperfect system.

#+begin_src emacs-lisp
(setq org-tag-alist
      '(("@administrative" . ?a) ; administrative tasks, paperwork, check-boxes, overhead, etc...
        ("@career"         . ?c) ; personal professional development (different than learn?)
        ("@communication"  . ?m) ; messaging, email, outreach, inquiry, and publication work
        ("@finances"       . ?f) ; banking, budgeting, investing, and most things money related
        ("@firefights"     . ?F) ; incident response, unexpected/chaotic work, high-urgency (war-room, incident team, etc...)
        ("@guild"          . ?g) ; involvement in communities of practice
        ("@health"         . ?h) ; exercise, diet, point-of-care, etc...
        ("@hiring"         . ?i) ; talent acquisition: outreach, correspondence, and interviewing
        ("@home"           . ?H) ; apartment related things
        ("@learn"          . ?l) ; courses, intentional learning, study (different than career?)
        ("@office"         . ?o) ; general office tasks (un-bucketed)
        ("@read"           . ?r) ; books and reading nook items
        ("@review"         . ?R) ; periodic review - timed reminders (tickler)
        ("@scheduling"     . ?d) ; calendar work, planning, conflict resolution
        ("@self"           . ?S) ; personal reflection and planning
        ("@sprint"         . ?s) ; sprint work (primarily development)
        ("@travel"         . ?t) ; trip planning, packing, and similar
        ("@workstation"    . ?w) ; home and office hardware, configs, etc...
        ("IMPORTANT"       . ?I) ; something of significance or of great value
        ("NEXT"            . ?N) ; the very next thing to be doing within a project
        ("PROJECT"         . ?P) ; something that takes significant effort or time, and can be decomposed into individual tasks
        ("TASK"            . ?T) ; an atomic actionable thing
        ("URGENT"          . ?U) ; something that demands attention in a short timespan
        ("journal"         . ?j)))

(setq org-stuck-projects '("+PROJECT/-WAITING-DONE"
                           ("TODO" "STARTED") ()))
#+end_src

For speedup purposes, I could define tags on every file instead of using inheritance.
#+begin_src emacs-lisp
(setq org-agenda-use-tag-inheritance nil)
;;(setq org-tags-exclude-from-inheritance '("PROJECT" "NEXT"))
#+end_src


*** TODO Archiving
I typically only look back a sprint, about two weeks, for recent time tracking.

Thankfully, John Wiegley shared [[https://orgmode.org/list/m21wc7dz4r.fsf@newartisans.com/][a solution]] for this that I now use. Although, it doesn't quite work yet. Do I have the
right hooks set?

#+begin_src emacs-lisp
(defvar org-my-archive-expiry-days 15
  "The number of days after which a completed task should be auto-archived.
This can be 0 for immediate, or a floating point value.")

(defun org-my-archive-done-tasks ()
  "Archive completed org tasks."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((done-regexp
           (concat "\\* \\(" (regexp-opt org-done-keywords) "\\) "))
          (state-regexp
           (concat "- State \"\\(" (regexp-opt org-done-keywords)
                   "\\)\"\\s-*\\[\\([^]\n]+\\)\\]")))
      (while (re-search-forward done-regexp nil t)
        (let ((end (save-excursion
                     (outline-next-heading)
                     (point)))
              begin)
          (goto-char (line-beginning-position))
          (setq begin (point))
          (if (re-search-forward state-regexp end t)
              (let* ((time-string (match-string 2))
                     (when-closed (org-parse-time-string time-string)))
                (if (>= (time-to-number-of-days
                         (time-subtract (current-time)
                                        (apply #'encode-time when-closed)))
                        org-my-archive-expiry-days)
                    (org-archive-subtree)))
            (goto-char end)))))
    (save-buffer)))

(setq safe-local-variable-values (quote ((after-save-hook archive-done-tasks))))

(defalias 'archive-done-tasks 'org-my-archive-done-tasks)
#+end_src


** Org Clocking
Org-mode gives us the ability to track time by clocking in and out of headlines. Combined with to-do items and agendas,
we can really get some value out of this functionality.

#+begin_src emacs-lisp
(setq org-clock-continuously t
      org-clock-in-resume t
      org-clock-into-drawer 1
      org-clock-out-remove-zero-time-clocks t
      org-clock-out-when-done t
      org-clock-persist t
      org-clock-report-include-clocking-task t
      org-treat-insert-todo-heading-as-state-change t
      org-expiry-inactive-timestamps t
      org-log-done 'time
      org-log-into-drawer "LOGBOOK"
      org-clock-in-switch-to-state "STARTED")

;; TODO: Move these somewhere more appropriate
(setq org-src-window-setup 'current-window)
(setq org-html-postamble nil)

(org-clock-persistence-insinuate); Resume clocking task when emacs is restarted
#+end_src


** Capture Templates
Capture templates allow us to quickly invoke a key-chord and select a template to capture some thought directly to a
good home for it. Tasks to my organizer or inbox, new journal items to my journal, etc...

I define these by initializing my capture list with an inbox capture and appending additional templates after. I do this
so I can split the configuration up and describe them better in my literate configuration.

#+begin_src emacs-lisp
;; Org Capture Configuration
(defvar TT/org-capture-templates (list) '())

;; The list needs to be initialized for setcdr to work later
(setq TT/org-capture-templates
      '(("i" "Inbox" entry  (file+olp TT/org-inbox "Capture" "Todos")
         "* TODO %? :TASK:\n /Entered on/ %U" :empty-lines 1)))
#+end_src

*** Helper Functions
Lets set up helpers. These are functions I'll use in my capture templates to extend the functionality of templates
themselves. These help make decisions, generate names, and do anything else I could need.

#+begin_src emacs-lisp
;;; BEGIN Capture Helpers
(defun region-to-clocked-task (start end)
  "Copies the selected text, from START to END, to the currently clocked in `org-mode` task."
  (interactive "r")
  (org-capture-string (buffer-substring-no-properties-start end) "C"))
(global-set-key (kbd "C-<F1>") 'region-to-clocked-task)

(defun capture-incident-response-file (path)
  "Generate dated file at capture PATH using interactively provided description."
  (interactive)
  (let ((name (read-string "Alert Name: ")))
    (expand-file-name
     (format "%s_%s.org" (format-time-string "%Y%m%d") name)
     path)))

(defun org-capture-inbox ()
  "Capture to inbox."
  (interactive)
  (call-interactively 'org-store-link)
  (org-capture nil "i"))
;;; END Capture Helpers
#+end_src


*** Sprint Work
Here I define my first capture group for Sprint Work. All templates within capture some work associated directly with
the current sprint I'm working in.

As a manger I don't presently do the sprint work that my teams execute, so this configuration is not exported. Instead,
I keep it around for reference.

#+begin_src emacs-lisp :tangle no
;; Capture group for Sprint Work
(setcdr (last TT/org-capture-templates)
        '(("s" "Sprint Capture Group")
          ("sd" "Development Task" entry (file+olp TT/org-organizer "Current Sprint" "Development")
           "* TODO [#B] %? :@sprint:TASK:\n")
          ("sv" "Review Task" entry (file+olp TT/org-organizer "Current Sprint" "Review")
           "* TODO [#B] %? :@sprint:TASK:\n")
          ("sr" "Research Task" entry (file+olp TT/org-organizer "Current Sprint" "Research")
           "* TODO [#B] RESEARCH: %? :@sprint:TASK:\n")
          ("ss" "Spike Task" entry (file+olp TT/org-organizer "Current Sprint" "Research")
           "* TODO [#B] SPIKE: %? :@sprint:TASK:\n")
          ("si" "Interrupt" entry (file+olp TT/org-organizer "Current Sprint" "Other")
           "* TODO [#A] %? :@sprint:TASK:URGENT:\n")
          ("st" "Other Task" entry (file+olp TT/org-organizer "Current Sprint" "Other")
           "* TODO [#B] %? :@sprint:TASK:\n")))
#+end_src


*** Retrospective Items
This second capture group is for capturing information observations and information related to how the sprint is
going. Capture in the moment, make sense through reflection, synthesize for retrospective and present to the
team. That's the general idea.

#+begin_src emacs-lisp
;; Capture Group for Retrospective Items
(setcdr (last TT/org-capture-templates)
        '(("r" "Retrospective Capture Group")
          ("rk" "Kudos" item (file+olp TT/org-retrospective "Capture" "Kudos")
           "- %?")
          ("rg" "Goodness" item (file+olp TT/org-retrospective "Capture" "Goodness")
           "- %?")
          ("rb" "Badness" item (file+olp TT/org-retrospective "Capture" "Badness")
           "- %?")
          ("rz" "Kaizen" item (file+olp TT/org-retrospective "Capture" "Kaizen")
           "- %?")))
#+end_src


*** Office Work Capture
As I made the transition from engineering work to management I found myself overusing the "office" context I originally
had for non-development in-office work. This capture group helps me better capture tasks I find myself regularly doing
as a manager, and better categorizes things within sub-groups of the "office" context.

#+begin_src emacs-lisp
;; Capture Group for Office Work
(setcdr (last TT/org-capture-templates)
        '(("o" "Office Capture Group")
          ("oa" "Administrative" entry (file+olp TT/org-organizer "Office" "Administrative")
           "* TODO [#B] %? :@office:@administrative:TASK:\n")
          ("oc" "Communication" entry (file+olp TT/org-organizer "Office" "Communication")
           "* TODO [#B] %? :@office:@communication:TASK:\n")
          ("of" "Firefighting" entry (file+olp TT/org-organizer "Office" "Firefighting")
           "* TODO [#A] %? :@office:@firefights:TASK:URGENT:\n")
          ("oh" "Hiring" entry (file+olp TT/org-organizer "Office" "Hiring")
           "* TODO [#B] %? :@office:@hiring:TASK:\n")
          ("os" "Scheduling" entry (file+olp TT/org-organizer "Office" "Scheduling")
           "* TODO [#B] %? :@office:@scheduling:TASK:\n")
          ("ot" "Task" entry (file+olp TT/org-organizer "Office" "General")
           "* TODO [#B] %? :@office:TASK:\n")))
#+end_src


*** Organizer To Do Items
This capture group is for non-sprint related tasks, which should each go to their proper group and have a default
priority based on how I typically file similar tasks. These can easily be adjusted up or down via the agenda view, so
it's perfectly fine for them to be inaccurate for the task, as long as they're typically correct.

Ideally there should be a capture template direct to every single level headline in my organizer. Each headline with
sub-headings ideally will have it's own capture group

#+begin_src emacs-lisp
;; Non-Sprint Todo Capture Group
(setcdr (last TT/org-capture-templates)
        '(("t" "General Todo Capture Group")
          ("tc" "Career Task" entry (file+headline TT/org-organizer "Career")
           "* TODO [#B] %? :@career:TASK:\n")
          ("th" "Health Task" entry (file+headline TT/org-organizer "Health & Wellness")
           "* TODO [#B] %? :@health:TASK:\n")
          ("to" "Home Task" entry (file+headline TT/org-organizer "Home")
           "* TODO [#B] %? :@home:TASK:\n")
          ("tf" "Financial Task" entry (file+headline TT/org-organizer "Finances")
           "* TODO [#B] %? :@finances:TASK:\n")
          ("tg" "Guild Task" entry (file+headline TT/org-organizer "Guild")
           "* TODO [#C] %? :@guild:TASK:\n")
          ("tr" "Reading Task" entry (file+headline TT/org-organizer "Reading")
           "* TODO [#B] %? :@read:TASK:\n")
          ("tv" "Travel Task" entry (file+headline TT/org-organizer "Travel")
           "* TODO [#B] %? :@travel:TASK:\n")
          ("tw" "Workstation Task" entry (file+headline TT/org-organizer "Workstation")
           "* TODO [#C] %? :@workstation:TASK:\n")
          ("tt" "General Task" entry (file+headline TT/org-organizer "Tasks")
           "\n* TODO [#C] %? :TASK:\n %i\n %a\n\n")))
#+end_src


*** TODO Incubator
Sometimes I want to capture an idea that I know I cannot take immediate action on. Instead of adding noise to my agenda
reports, let's file these as someday-maybe under =TT/org-incubate-dir=.


*** Meetings
This capture group is for meetings tied to the calendar.

I'd prefer to auto-populate the date with today's date and the repeat offset, but haven't found a smooth way to do it
yet. So for now, I schedule to an arbitrary date and update the date with =C-s= as I fill out the template.

#+begin_src emacs-lisp
;; Capture Group for Meetings
(setcdr (last TT/org-capture-templates)
        '(("m" "Meeting Capture Group")
          ("mm" "Pop Up Meetings and One-Offs" entry (file+olp TT/org-calendar "Meetings" "One Offs")
           "* MEETING %?\n\tSCHEDULED: %^t")
          ("md" "Daily Meeting" entry (file+olp TT/org-calendar "Meetings" "Daily")
           "* MEETING %?\n\tSCHEDULED: <2020-01-01 Sat ++1d>")
          ("mw" "Weekly Meeting" entry (file+olp TT/org-calendar "Meetings" "Weekly")
           "* MEETING %?\n\tSCHEDULED: <2020-01-01 Sat ++1w>")
          ("m1" "1:1 Meeting" entry (file+olp TT/org-calendar "Meetings" "1:1s")
           "* MEETING %?\n\tSCHEDULED: <2000-01-01 Sat ++1w>")
          ("mb" "Bi-Weekly Meeting" entry (file+olp TT/org-calendar "Meetings" "Bi-Weekly")
           "* MEETING %?\n\tSCHEDULED: <2000-01-01 Sat ++2w>")))
#+end_src


*** Miscellaneous
The remaining capture templates are things that don't fit neatly into any one group.

#+begin_src emacs-lisp
;; Other Capture Templates (un-grouped)
(setcdr (last TT/org-capture-templates)
        '(("j" "Journal" entry (function org-journal-find-location)
           "* %(format-time-string org-journal-time-format)%^{Title}\n%i%?")
          ("n" "Note" entry (file+olp TT/org-inbox "Capture" "Notes")
           "* %?\n:PROPERTIES:\n:CREATED:%U:END:\n\n%i\n\nFrom: %a" :empty-lines 1)
          ("m" "Manager Notes" item (file+olp TT/org-manager "1:1 Prep" "Capture")
           "- %?" :empty-lines 1)
          ("x" "Incident Notes" entry (file (capture-incident-response-file "~/org/incidents"))
           "* Incident Trigger\n%?\n\n* Five Whys\n\n* Action Items\n\n" :clock-in t)
          ("X" "Item to Current Clock" item
           (clock)
           "%i%?" :empty-lines 1)
          ("C" "Region to Current Clock" plain
           (clock)
           "%i" :immediate-finish t :empty-lines 1)))
#+end_src

**** TODO Needs Work [0/1]
- [ ] The =C-c c x= 'Incident Notes' capture template isn't working
 #+begin_example
 Invalid file location: nil
 #+end_example


*** Nested Groups Test
I had a hypothesis that I might be able to progressively define nested capture groups. This is the experiment that
showed it was possible. I keep it around for reference, but no longer export it into my configuration.

#+begin_src emacs-lisp :tangle no
;; Test capture group - testing nested sub-groups
(setcdr (last TT/org-capture-templates)
        '(("q" "Test Capture Group")
          ("qa" "Test Capture Sub-Group A")
          ("qaa" "AA Template" entry (file+olp TT/org-inbox "Test" "A" "AA")
           "* TODO [#A] %? :TASK:\n" :empty-lines 1)
          ("qaa" "AB Template" entry (file+olp TT/org-inbox "Test" "A" "AB")
           "* TODO [#B] %? :TASK:\n" :empty-lines 1)
          ("qb" "Test Capture Sub-Group B")
          ("qba" "BA Template" entry (file+olp TT/org-inbox "Test" "B" "BA")
           "* TODO [#A] %? :TASK:\n" :empty-lines 1)
          ("qbb" "BB Template" entry (file+olp TT/org-inbox "Test" "B" "BB")
           "* TODO [#B] %? :TASK:\n" :empty-lines 1)))
#+end_src


*** Setting Capture Templates
Because I've split the configuration up, it's time to update the actual =org-capture-templates= variable.

#+begin_src emacs-lisp
(setq org-capture-templates TT/org-capture-templates)
#+end_src

If I want to further customize this variable in machine local configurations, like in my employer configuration, I'll
have to append to =org-capture-templates=. I could wait to set the value at the very end, but right now I think it makes
more sense to keep local to this section.


** Org Journal
Let's set up where my journal files are stored, and the format of the entries.

#+begin_src emacs-lisp
(use-package org-journal
  :init (setq org-journal-dir TT/org-journal-dir
              org-journal-file-format "%Y%m%d"
              org-journal-date-format "%e %b %Y (%A)")
  :config (setq org-journal-date-prefix "#+TITLE: Daily Note for "))
#+end_src

*** Journal Helpers
These are functions that will later enable us to interact with org-journal via capture templates, etc...

#+begin_src emacs-lisp
(defun get-journal-file-yesterday ()
  "Gets filename for yesterday's journal entry."
  (let* ((yesterday (time-subtract (current-time) (days-to-time 1)))
         (daily-name (format-time-string "%Y%m%d" yesterday)))
    (expand-file-name (concat org-journal-dir daily-name))))

(defun journal-file-yesterday ()
  "Create and load a file based on yesterday's date."
  (interactive)
  (find-file (get-journal-file-yesterday)))

(defun org-journal-find-location ()
  "Open today's journal.
    Specify a non-nil prefix to inhibit inserting the heading"
  (org-journal-new-entry t)
  (goto-char (point-min)))
#+end_src


** Org Refile
Despite having some nice capture templates, sometimes things still don't end up in the right place. That, or
sometimes I just want to move something.

#+begin_src emacs-lisp
(setq org-refile-targets '((org-agenda-files :maxlevel . 6)))
;;(setq org-outline-path-complete-in-steps nil)
(setq org-refile-allow-creating-parent-nodes 'confirm)
#+end_src


** Org Linking
Org-mode supports creating links to various resources across org-mode files and materials online.

Let's create some short links for things I might reference often.

#+begin_src emacs-lisp
;; Links - use like: cpan:HTML or rfc-txt:7522
(setq org-link-abbrev-alist
      '(("rfc-html" . "https://tools.ietf.org/html/rfc%s")
        ("rfc-txt"  . "https://tools.ietf.org/rfc/rfc%s.txt")
        ("rfc-pdf"  . "https://tools.ietf.org/pdf/rfc%s.pdf")
        ("fhir-r4"  . "https://www.hl7.org/fhir/R4/%s")
        ("us-core"  . "https://www.hl7.org/fhir/us/core/%s")
        ("cpan"     . "https://metacpan.org/search?q=%s")
        ("so"       . "https://stackoverflow.com/search?q=%s")
        ("soq"      . "https://stackoverflow.com/questions/%s")
        ("ese"      . "https://emacs.stackexchange.com/search?q=%s")
        ("eseq"     . "https://emacs.stackexchange.com/questions/%s")))
#+end_src


** Org Publish
I can even use org-mode to publish static content!

#+begin_src emacs-lisp
(setq org-publish-project-alist
      '(("notes-content"
         :base-directory "~/org/testnotes"
         :base-extension "org"
         :publishing-directory "~/public_html/"
         :recursive t
         :publishing-function org-html-publish-to-html
         :headline-levels 4
         :auto-preamble t)
        ("notes-static"
         :base-directory "~/org/testnotes"
         :base-extensions "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf"
         :publishing-directory "~/public_html" ; could be TRAMP path
         :recursive t
         :publishing-function org-publish-attachment)
        ("notes" :components ("notes-content" "notes-static"))))

;; TODO: https://github.com/fniessen/org-html-themes or other
#+end_src


** Org-Babel

*** Supporting Tools
Using org-babel, we can pull in some graphical helper tools to give it some rendering capabilities.

#+begin_src emacs-lisp
(setq org-ditaa-jar-path "/usr/bin/ditaa.jar")
(setq org-plantuml-jar-path "/usr/share/plantuml/plantuml.jar")
#+end_src


*** Displaying Inline Images
Let's make it so org-babel can display images in org files directly.

#+begin_src emacs-lisp
(defun bh/display-inline-images ()
  "Display inline images."
  (condition-case nil
      (org-display-inline-images)
    (error nil)))

(add-hook 'org-babel-after-execute-hook 'bh/display-inline-images 'append)
#+end_src


*** Configuring Supported Languages
I'm only going to configure the subset of languages I use, but there are way more to choose from.

#+begin_src emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((C          . t)
   (ditaa      . t)
   (dot        . t)
   (emacs-lisp . t)
   (gnuplot    . t)
   (js         . t)
   (latex      . t)
   (ledger     . t)
   (org        . t)
   (perl       . t)
   (plantuml   . t)
   (python     . t)
   (shell      . t)
   (sql        . t)
   (sqlite     . t)))
#+end_src


*** Final Things
With =org-bable= mostly configured, lets plug it into some other stuff.

#+begin_src emacs-lisp
(add-to-list 'org-src-lang-modes (quote ("plantuml" . fundamental)))
#+end_src


** TODO Org References
I want to refile these closer to where their contents are more applicable.

- https://orgmode.org/manual/Template-elements.html
- https://orgmode.org/manual/Template-expansion.html
- https://orgmode.org/manual/Refile-and-Copy.html
- https://orgmode.org/manual/Configuration.html Projects for publishing


* Development Interactions
This section contains customizations for development and working within coding environments.

** General Settings
A few things across languages first.

*** Tabs v. Spaces
Let the holy wars be resolved by tooling that enables each developer to see things their way in their editor, and
tooling that converts these to whatver is standard for the codebases we collaborate in.

Set tabbing to spaces, keep things condensed with 2 spaces.

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
(setq tab-width 2)
#+end_src


** Editor Config
See [[https://editorconfig.org/][EditorConfig.org]] for more details. However, this helps me play nice across source repositories, and helps keep
contributors happily using their own editor/IDE.

#+begin_src emacs-lisp
(use-package editorconfig
  :ensure t
  :diminish editorconfig-mode
  :config
  (editorconfig-mode 1))
#+end_src


** TODO Language Server
The Language Server Protocol (LSP) sets up a contract for an editor (client) to chat with a language server to reduce
development burden of supporting language interactions across languages and editors. Instead, the server can worry about
supporting language interactions and any editor with a client can get the benefit of that abstraction.

Emacs has both the [[https://github.com/emacs-lsp/lsp-mode][lsp-mode]] and [[https://github.com/joaotavora/eglot][eglot]] packages to support client interfaces with various language server backends. I've
chosen to leverage =lsp-mode= as my language server client.

#+begin_src emacs-lisp
;; LSP mode configuration
(use-package lsp-mode
  :commands lsp
  :hook (c++-mode python-mode go-mode-hook)
  :init
  (setq lsp-prefer-flymake nil))

(use-package lsp-ui :commands lsp-ui-mode)
(use-package company-lsp :commands company-lsp)
#+end_src


** On The Fly Checking
Fly-Check enables on the fly syntax checking which helps me catch errors as I write them and prompts me to fix them
immediately. This enforces a tight feedback loop in development.

#+begin_src emacs-lisp
(use-package flycheck)

(add-hook 'after-init-hook #'global-flycheck-mode)

(setq flycheck-checkers
      (quote (asciidoc
              c/c++-cppcheck
              css-csslint
              emacs-lisp
              emacs-lisp-checkdoc
              handlebars
              html-tidy
              javascript-eslint
              json-jsonlint
              less
              make
              perl
              perl-perlcritic
              python-flak8
              python-pylint
              rust
              sh-bash
              sh-zsh
              sh-spellcheck
              tex-chktex
              tex-lacheck
              texinfo
              xml-xmlstarlet
              xml-xmllint
              yaml-jayaml)))
;; Others: cfenging chef-foodcritic coffee coffee-coffeelint d-dmd elixir
;;         erlang eruby-erubis go-gofmt go-golint go-vet go-build go-test
;;         haml haskell-ghc haskell-hlint lua php php-phpmd php-phpcs
;;         puppet-parser puppet-lint racket rst rst-sphinx ruby-rubocop
;;         ruby-rubylint ruby ruby-jruby sass scala scss slim verilog-verilator

(setq-default flycheck-disabled-checkers
              '((javascript-jshint
                 javascript-jslint
                 javascript-gjslint
                 c/c++-clang)))

;; Enable C++14 support for GCC
(add-hook 'c++-mode-hook (lambda () (setq flycheck-gcc-language-standard "c++14")))

;; Use project relative eslint; see https://emacs.stackexchange.com/questions/21205
(defun TT/use-eslint-from-node-modules ()
  "Use project local eslint node modules."
  (let* ((root (locate-dominating-file
                (or (buffer-file-name) default-directory)
                "node_modules"))
         (eslint (and root
                      (expand-file-name "node_modules/eslint/bin/eslint.js"
                                        root))))
    (when (and eslint (file-executable-p eslint))
      (setq-local flycheck-javascript-eslint-executable eslint))))

(add-hook 'flycheck-mode-hook #'TT/use-eslint-from-node-modules)

;; Enable flycheck globally:
(add-hook 'after-init-hook #'global-flycheck-mode)

;; See: https://emacs.stackexchange.com/questions/13065
;; (defun setup-flycheck-clang-project-path ()
;;   "Use project local clang."
;;   (let ((root (ignore-errors (projectile-project-root))))
;;   (when root
;;     (add-to-list
;;      (make-variable-buffer-local 'flycheck-clang-include-path)
;;      root))))

;; (add-hook 'c++-mode-hook 'setup-flycheck-clang-project-path)
#+end_src


** Company Completions
Company-mode, or complete any mode, is an extremely useful tool for text/code completion.

#+begin_src emacs-lisp
(use-package company
  :ensure t
  :diminish
  :bind (:map company-active-map
              ("M-n" . nil)
              ("M-p" . nil)
              ("C-n" . company-select-next)
              ("C-p" . company-select-previous))
  :init (global-company-mode)
  :config
  (setq company-tooltip-align-annotations t
        company-idle-delay nil
        company-minimum-prefix-length 2
        company-require-match nil
        company-show-numbers t
        company-tooltip-limit 20)
  (with-eval-after-load 'company
    (global-set-key (kbd "C-c SPC") 'company-complete)))
#+end_src

It also plugs into =lsp-mode= which I'll be setting up later.
#+begin_src emacs-lisp
(use-package company-lsp
  :after (company lsp-mode)
  :commands company-lsp
  :config
  (push 'company-lsp company-backends))
#+end_src


** Projectile Project Management
Projectile allows for project interaction from within Emacs. Additionally, it can hook into other powerful search
utilities to really kick up project navigation.

#+begin_src emacs-lisp
(use-package projectile
  :ensure t
  :config
  (setq projectile-completion-system 'helm)
  (setq projectile-switch-project-action 'helm-projectile)
  (setq projectile-enable-caching t)
  (setq projectile-globally-ignored-directories
        '(".git" "node_modules" "__pycache__" ".vs"))
  (setq projectile-globally-ignored-file-suffixes
        '("#" "~" ".swp" ".o" ".so" ".exe" ".dll" ".elc" ".pyc" ".jar"))
  (setq projectile-globally-ignored-files
        '("TAGS" "tags"))
  (with-eval-after-load "projectile"
    (projectile-mode)
    (helm-projectile-on)))

(use-package helm-projectile)
#+end_src


** TODO =magit= and Version Control
Magical Git interactions in Emacs.

#+begin_src emacs-lisp
(setq vc-handled-backends (delq 'Git vc-handled-backends))

(use-package magit
  :ensure t
  :defer t
  :bind ("C-x g" . magit-status))
   #+end_src


** TODO =treemacs=


** Language Configurations

*** Mode Bindings by File Type
Make sure certain files open in certain modes.

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.py$"          . python-mode))
(add-to-list 'auto-mode-alist '("\\.org$"         . org-mode))
(add-to-list 'auto-mode-alist '("\\.ts$"          . typescript-mode))
(add-to-list 'auto-mode-alist '("\\.css$"         . css-mode))
(add-to-list 'auto-mode-alist '("\\.md$"          . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.markdown$"    . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.hbs$"         . handlebars-mode))
(add-to-list 'auto-mode-alist '("\\.README\\.md$" . gfm-mode))
(add-to-list 'auto-mode-alist '("Jenkinsfile$"    . groovy-mode))
#+end_src


*** Perl Customizations
I used to write mostly in Perl for work, and =cperl-mode= was what my Emacs wielding colleagues used at my
employer. It was definitely better than the Vanilla Emacs defaults.

#+begin_src emacs-lisp
(use-package cperl-mode)

(setq cperl-close-paren-offset 0
      cperl-continued-statement-offset 0
      cperl-electric-backspace-untabify nil
      cperl-indent-comment-at-column-0 t
      cperl-indent-parens-as-block t
      cperl-label-offset 0
      cperl-min-label-indent 0
      perl-tab-to-comment t)

(defalias 'perl-mode 'cperl-mode)
(defvaralias 'c-basic-offset 'tab-width)
(defvaralias 'cperl-indent-level 'tab-width)

;; Override perl-mode with cperl-mode
(mapc
 (lambda (pair)
   (if (eq (cdr pair) 'perl-mode)
       (setcdr pair 'cperl-mode)))
 (append auto-mode-alist interpreter-mode-alist))
#+end_src


*** JavaScript
From time to time I've developed either tangentially or immersively in JavaScript, both in the Web and in
Node. =js2-mode= has been good to me for that. I tried =js3-mode=, but found it lacked features and had fallen out of
support. I'm somewhat eyeing =indium=, but would likely prefer to just use a =lsp-mode= solution that also supports
Typescript.

#+begin_src emacs-lisp
(use-package js2-mode
  :defer t
  :mode "\\.js$"
  :config
  (require 'js2-refactor)
  (define-key js2-mode-map (kbd "M-.") nil)
  (add-hook 'js2-mode-hook #'js2-refactor-mode)
  (js2r-add-keybindings-with-prefix "C-c C-r")
  (define-key js2-mode-map (kbd "C-k") #'js2r-kill)
  (setq js3-boring-indentation t
        js3-cleanup-whitespace t
        js3-consistent-level-indent-inner-bracket t
        js3-continued-expr-mult 0
        js3-curly-indent-offset 0
        js3-enter-indents-newline t
        js3-indent-level 4
        js3-indent-on-enter-key nil
        js3-indent-tabs-mode t)
  (add-hook 'js2-mode-hook
            (lambda ()
              (add-hook 'xref-backend-functions #'xref-js2-xref-backend nil t)))
  (add-hook 'js2-mode-hook
            (lambda ()
              (setq mode-name "js2"))))
#+end_src


*** TODO C/C++


* More Emacs Modes

** Ledger - Command Line Accounting
Ledger, the command line double booking entry system. A geeky way to track your finances, with support in Emacs via
=ledger-mode=!

#+begin_src emacs-lisp
(use-package ledger-mode
  :mode ("\\.ledger$")
  :bind (:map ledger-mode-map
              ("C-x C-s" . TT/ledger-save))
  :preface
  (defun TT/ledger-save ()
    "Automatically clean the ledger buffer at each save."
    (interactive)
    (save-excursion
      (when (buffer-modified-p)
        (with-demoted-errors (ledger-mode-clean-buffer))
        (save-buffer))))
  :init
  (setq ledger-post-amount-alignment-column 80))

(use-package flycheck-ledger
  :after ledger-mode)
#+end_src


** Internet Relay Chat with =erc=
Emacs comes with it's own Internet Relay Chat client, =ERC=. I use this to chat over IRC from right within Emacs.

#+begin_src emacs-lisp
(use-package erc
  :defer t
  :config
  (setq erc-nick "paraparity"
        erc-hide-list '("PART" "QUIT" "JOIN" "NICK")
        erc-server "irc.freenode.net"
        erc-kill-buffer-on-part t
        erc-scrolltobottom-mode t
        erc-autojoin-channels-alist '(("freenode.net" "##programming" "#org-mode"))))
#+end_src


** TODO PDF-Tools
PDF-Tools enable PDF viewing within Emacs, so I don't have to have a second application open to read and take notes on
PDF files. Just one more reason to never leave Emacs.

Unfortunately my current configuration has trouble doing a fresh install as this has a dependency on =pdf-tools= being
installed on the host running Emacs, which it may not be. On a system with this dependency installed we're up and
running no problem though.

#+begin_src emacs-lisp :tangle no
(use-package pdf-tools
  :pin manual
  :config
  (setq-default pdf-view-display-size 'fit-page)
  (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward))
#+end_src


* TODO Helper Functions
This section contains custom functions I'll sometimes invoke. These should probably live elsewhere, but for now, this is
their home.

#+begin_src emacs-lisp
;; Regardless of which buffer you're in, jump to the active minibuffer
(defun switch-to-minibuffer ()
  "Switch to minibuffer window."
  (interactive)
  (if (active-minibuffer-window)
      (select-window (active-minibuffer-window))
    (error "Minibuffer is not active")))

(defun occur-non-ascii ()
  "Find any non-ascii characters in the current buffer."
  (interactive)
  (occur "[[:nonascii:]]"))

(defun open-config-file ()
  "Open this file."
  (interactive)
  (find-file "~/.emacs.d/configuration.org"))
  #+end_src


* Global Keybinding Overrides
This section contains my global keybinding overrides. There are key-bindings defined elsewhere in my configuration,
typically within the context they'll be used in. This isn't a hard rule, but is what I lean towards.

#+begin_src emacs-lisp
;; Buffer Key Bindings
(global-set-key (kbd "S-w") 'kill-this-buffer)
(global-set-key (kbd "C-S-<left>") 'shrink-window-horizontally)
(global-set-key (kbd "C-S-<right>") 'enlarge-window-horizontally)
(global-set-key (kbd "C-S-<down>") 'shrink-window)
(global-set-key (kbd "C-S-<up>") 'enlarge-window)
(global-set-key (kbd "C-x |") 'window-toggle-split-direction)
(global-set-key (kbd "C-c o") 'switch-to-minibuffer)
(global-set-key (kbd "<f8>") 'flyspell-buffer)
(global-set-key (kbd "<f6>") 'speedbar)

;; Elfeed Keybindings
(global-set-key (kbd "C-x w") 'elfeed)

;; Misc Keybindings
(global-set-key (kbd "C-c 1") 'open-config-file)
(global-set-key (kbd "C-x #") 'comment-or-uncomment-region)
(global-set-key (kbd "C-c d") 'duplicate-current-line-or-region)
;;(global-set-key (kbd "M-.") 'find-tag-other-window)

;; Modal Key Bindings
(add-hook 'cperl-mode-hook
          (lambda ()
            (local-set-key (kbd "C-h f") 'cperl-perldoc)))
#+end_src

** Disable Problematic Bindings
Some keybindings are just the bane of my existence. While many are undoable, some cause more trouble that outweighs
the value of having the binding.

#+begin_src emacs-lisp
;; Kill the bane of my fat-fingers
(global-unset-key (kbd "C-z"))
(global-unset-key (kbd "C-x C-z"))
#+end_src


** Setup Org Global Interactions
I want to be able to start interacting with org-mode regardless of what buffer I'm presently in.

#+begin_src emacs-lisp
;; Org-Mode Keybindings
(global-set-key (kbd "C-c a") 'org-agenda)
(global-set-key (kbd "C-c c") 'org-capture)
(global-set-key (kbd "C-c l") 'org-store-link)
(global-set-key (kbd "C-c i") 'org-capture-inbox)
#+end_src


** Enable Full Keyboard Number Pad
Unfortunately I've found Emacs doesn't natively support full size keyboards, however this allows us to get our num-pad
working.

#+begin_src emacs-lisp
;; Numpad Key Bindings
(global-set-key "\eOp" "0")
(global-set-key "\eOq" "1")
(global-set-key "\eOr" "2")
(global-set-key "\eOs" "3")
(global-set-key "\eOt" "4")
(global-set-key "\eOu" "5")
(global-set-key "\eOv" "6")
(global-set-key "\eOw" "7")
(global-set-key "\eOx" "8")
(global-set-key "\eOy" "9")
(global-set-key "\eOl" "+")
(global-set-key "\eOn" ".")
#+end_src


* Completing Configuration
This section contains the last moment configurations that wrap up my personal customization and Emacs load. Here we'll
kill mode-line clutter and start up the Emacs server.

#+begin_src emacs-lisp
;; Make it so I can recover old sessions after close or reboot
(desktop-save-mode 1)

;; Load configuration files local to employer
;;(org-babel-load-file "~/.emacs.d/employer.org")

;; Start the Emacs server
(require 'server)
(unless (server-running-p)
  (defvar server-name (concat "server"(number-to-string (emacs-pid))))
  (ignore-errors (server-start))

  ;; Set the environment variables for *shell*.
  (setenv "EDITOR" (concat "~/usr/local/bin/emacsclient -s " server-name)))

;;(put 'narrow-to-region 'disabled nil)
#+end_src


* Future Work

** TODO Wishlist [0/1]
- [ ] Org file rendering in Github is still too indented; left align code blocks?
  - See [[https://github.com/howardabrams/dot-files/blob/master/emacs.org][Howard Abrams files]] to see what I'm aiming for.
  - Hmm... comparing my raw file with that one, it seems my org configuration is inserting tabs...
  - Ran =untabify= on buffer - still need to update settings to prevent issues
  - Hmm... tabs are still being really weid. I hate playing with whitespace in Emacs


** Configuration Reading
That's mostly it folks. Configuration is done, the rest are future works. This section collects other articles or
configurations I've stumbled across and bookmarked for eventual reading.

*** TODO List [0/39]
- [ ] https://github.com/hungptit/tools and integration w/ Emacs
- [ ] https://github.com/yjwen/org-reveal
- [ ] https://github.com/fniessen/org-html-themes
- [ ] =hydra=
- [ ] =ivy=
- [ ] =treemacs=
- [ ] =lsp-mode=, =lsp-ui=, =company-lsp=, =dap-mode=
- [ ] =org-journal=
- [ ] =org-brain=
- [ ] =bbdb=
- [ ] =ox-slimhtml=
- [ ] =realgud=
- [ ] bookmarks
- [ ] =epg=
- [ ] semantic
- [ ] tramp
- [ ] docker-tramp
- [ ] =fzf= - fuzzy file finding
- [ ] MacOS X / Linux config
- [ ] exec-path-from-shell
- [ ] REST client
- [ ] org-mode blogging
- [ ] markdown mode
- [ ] https://gitlab.com/jaor/geiser
- [ ] https://katherine.cox-buday.com/blog/2015/03/14/writing-specs-with-org-mode/
- [ ] http://kitchingroup.cheme.cmu.edu/blog/category/org-mode/
- [ ] https://ladicle.com/post/config/#screenshot
- [ ] https://orgmode.org/worg/org-web.html
- [ ] https://github.com/ianpan870102/.emacs.d
- [ ] http://emacs.cafe/emacs/orgmode/gtd/2017/06/30/orgmode-gtd.html
- [ ] https://joshrollinswrites.com/emacsorg/org-capture-template-1/
- [ ] http://www.howardism.org/Technical/Emacs/getting-boxes-done.html
- [ ] http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html
- [ ] https://orgmode.org/worg/org-tutorials/org-latex-export.html
- [ ] https://www.gnu.org/software/tramp/#Configuration
- [ ] http://doc.norang.ca/org-mode.html
- [ ] https://orgmode.org/worg/org-blog-articles.html
- [ ] https://lispcookbook.github.io/cl-cookbook/emacs-ide.html
- [ ] https://edwardtufte.github.io/tufte-css/
  - https://edwardtufte.github.io/et-book/
