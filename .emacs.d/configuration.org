#+TITLE: Paraparity's Literate Emacs Configuration
#+PROPERTY: header-args :tangle yes

* Overview
  A literate configuration is an org-mode file containing a heirarchical textual description of the reasoning behind
  configuration settings and ~emacs-lisp~ source blocks which contain the actual configuration settings. These source
  blocks get "tangled" by ~org-babel~ and loaded by Emacs.

  The reasons for and against such a file are many. Ultimately it comes down to how you personally want to write and
  maintain your configuration. This is the Emacs way.

  Personally, I've maintained ~.emacs~ configurations, ~init.el~ configurations, and configurations split into many
  files within the ~.emacs.d~ directory, each loaded by some core config file. Like many, I've declared Emacs bankruptcy
  before and started over again, each time trying something new. This time however, I'm transferring my balance directly
  to a literate configuration and refactoring my debt from there.

  The reasons I am doing this are twofold
  - to try my hand at maintaining a literate configuration and collect first hand empirical evidence
  - to tell a story about how and why I've arrived at the configuration herein

  Considering that my configuration changes relatively little piece by piece, maintaining the literate side of things
  shouldn't be too much overhead. Additionally, I'm expecting to benefit in terms of maintainability by being able to
  re-read the context of why I've made certain configuration choices.

  Welcome aboard my ship of Theseus.


* General Settings

** Add Some Output Commentary
   When tangled, all of these source blocks become an ~.el~ file. I'd still like that to be more friendly than just a
   bunch of configuration code, so let's keep the old ~init.el~ header around with some updates.

   #+begin_src emacs-lisp
	 ;;; configuration.el --- paraparity's Emacs configuration file
	 ;;
	 ;;; Commentary:
	 ;; Customized startup for Emacs
	 ;;
	 ;;; Code:

	 ;; Eternally grateful to have gleaned lessons from:
	 ;;   http://pages.sachachua.com/.emacs.d/Sacha.html
	 ;;   https://github.com/purcell/emacs.d
	 ;;   https://github.com/howardabrams/dot-files
	 ;;   https://github.com/skeeto/.emacs.d
   #+end_src


** Setup Load Paths
   Emacs only includes packages under the ~user-emacs-directory~ (default ~~/.emacs.d/elpa/~), so if we want to load anything
   else up we'll need to tell Emacs where to look.

   #+begin_src emacs-lisp
	 (add-to-list 'load-path "~/.emacs.d/elpa")
	 (add-to-list 'load-path "~/.emacs.d/elisp/")
   #+end_src

   Load my machine local custom librariers directly, if they exist. Elfeed is only machine local because I've been lazy
   in sharing it, and also I only pay attention to work related feeds on my work machine.
   #+begin_src emacs-lisp
	 (if (file-readable-p "~/.emacs.d/elisp/elfeed-conf.el")
		 (load-library "elfeed-conf"))
   #+end_src

*** TODO Revise Elfeed Configuration
	Do as the section header says


** Kill Dir-Locals
   Since I don't use directory local variables for Emacs very much if at all, and considering they could load arbitrary
   emacs-lisp, potentially without my knowing, lets prevent that from happening.

   #+begin_src emacs-lisp
	 (setq enable-local-eval nil
		   enable-local-variables nil)
   #+end_src


** Encoding Systems
   Pretty much just set the coding system to UTF-8. Also enable the Japanese language environment to support study.

   #+begin_src emacs-lisp
	 (prefer-coding-system 'utf-8)
	 (set-keyboard-coding-system 'utf-8)
	 (set-terminal-coding-system 'utf-8)
	 (set-selection-coding-system 'utf-8)
	 (set-default-coding-systems 'utf-8)

	 (set-language-environment "japanese")
   #+end_src


*** TODO Identify Need and Refactor
	I wonder if I need to set all of these individually, or if I could just get by with default or something else?


** Emacs Appearance
*** Kill Unnecessary Default Clutter
	Give me back my screen real estate. I don't need your newfangled and fancy GUI features, they just get in the way of
	more lines of sweet, sweet text.

	#+begin_src emacs-lisp
	  (setq inhibit-startup-screen t
			inhibit-startup-message t
			initial-scratch-message nil)

	  (tool-bar-mode -1)
	  (menu-bar-mode -1)
	  (scroll-bar-mode -1)
	#+end_src


*** Style Our Frame
	Let's give Emacs a name, I think Emacs sounds nice.
	#+begin_src emacs-lisp
	  (setq frame-title-format "Emacs")
	#+end_src

	Let's make sure our buffers have unique names. If we were to open a file of the same name, but a different location
	we only need them to be a little unique, not full file path or even relative file path unique.
	#+begin_src emacs-lisp
	  (use-package uniquify :ensure nil)
	#+end_src

	Let's get some more screen real estate by using a small, code friendly font.
	#+begin_src emacs-lisp
	  (set-frame-font "monospace-11")
    #+end_src

	Let's keep track of time in the mode-line.
	#+begin_src emacs-lisp
	  (display-time-mode 1)
	#+end_src

	Let's add some transparency to make things look really slick.
	#+begin_src emacs-lisp
	  (set-frame-parameter (selected-frame) 'alpha '(92 . 90))
	  (add-to-list 'default-frame-alist '(alpha . (92 . 90)))
	#+end_src

	Display which-function-mode, and do so in headerline instead of mode line.

	#+begin_src emacs-lisp
	  (which-function-mode)
	  (setq mode-line-misc-info (delete (assoc 'which-func-mode
						   mode-line-misc-info) mode-line-misc-info)
			which-func-header-line-format '(which-func-mode ("" which-func-format)))

	  (defadvice which-func-ff-hook (after header-line activate)
		(when which-func-mode
		  (setq mode-line-misc-info (delete (assoc 'which-func-mode
							   mode-line-misc-info) mode-line-misc-info)
			header-line-format which-func-header-line-format)))
	#+end_src


*** Improve Navigation Experience
	Let's keep track of the currently focused line, always, everywhere.
	#+begin_src emacs-lisp
	  (global-hl-line-mode t)
	#+end_src

	Let's make it easy to see current block parens, given they're both on screen.
	#+begin_src emacs-lisp
	  (show-paren-mode 1)
	#+end_src


*** Hunt Trailing Whitespace, Sometimes
	I personally disdain trailing whitespace, but also dislike how visually congested whitespace-mode can be
	sometimes. As such, lets make things toggleable so I can inspect whitespace on demand with only a key chord. Also,
	lets give ourselves a nuclear option for stripping trailing whitespace.

	#+begin_src emacs-lisp
	  (defun para/toggle-trailing-whitespace ()
		"Toggle 'show-trailing-whitespace' between t and nil."
		(interactive)
		(setq show-trailing-whitespace (not show-trailing-whitespace)))

	  (global-set-key (kbd "C-c w m") 'whitespace-mode)
	  (global-set-key (kbd "C-c w t") 'para/toggle-trailing-whitespace)
	  (global-set-key (kbd "<f5>") 'delete-trailing-whitespace)
	#+end_src


** Various Emacs Settings
   Enable quick Y/N prompts.
   #+begin_src emacs-lisp
	 (fset 'yes-or-no-p 'y-or-n-p)
   #+end_src

   Get rid of that annoying bell.
   #+begin_src emacs-lisp
	 (setq ring-bell-function 'ignore)
   #+end_src

   Enable final newline in all files. It's pretty common in software projects, and it's just a habit by now, I'll
   include it everywhere until I find somewhere that bites me because of it.
   #+begin_src emacs-lisp
	 (setq require-final-newline t)
   #+end_src

   At one point I had some slowness with cursor movement and scrolling. I forget why at this point, but I stumpled upon
   some answer that said disable this, and I've never looked back since.
   #+begin_src emacs-lisp
	 (setq auto-window-vscroll nil)
   #+end_src

   This probably deserves it's own section and some more configuration, but for now here's a minimal GPG setup.
   #+begin_src emacs-lisp
	 (setq epg-gpg-program "gpg2")

	 ;; Auth
	 (setq auth-sources
		   '((:source "~/.emacs.d/secrets/.authinfo.gpg")))
   #+end_src

*** Manage File Backups and Auto Save
	Emacs can get a bit aggressive with file backups and autosaves. I particularly dislike how it can pollute my
	directories and especially collaborative projects with tilde files (e.g: =myfile.txt~=). Usually things like
	=.gitignore= are sufficient to insulate others from these, but I'd prefer not to see them myself.

	#+begin_src emacs-lisp
	  ;; File Backup Management
	  (setq backup-by-copying t
			backup-directory-alist `(("." . "~/saves"))
			delete-old-versions t
			kept-new-versions 6
			kept-old-versions 2
			version-control t)

	  ;; Autosave File Management
	  (setq auto-save-file-name-transforms
			`((".*" ,temporary-file-directory t)))
	#+end_src


*** Offload Custom File
	I don't want Emacs customize managed settings ending up in my init files, so lets give them their own nice little
	home. Every now and again I should go through and convert much of whatever is there into my literate configuration.

	#+begin_src emacs-lisp
	  (setq custom-file "~/.emacs.d/custom.el")
	  (when (file-exists-p custom-file)
		(load custom-file 'noerror))
	#+end_src


** Easy Config Editing
   Let's make it a only take a key-chord to pull up my literate configuration.

   #+begin_src emacs-lisp
	 (defun para/locate-literate-config ()
	   "Locate and load my literate configuration file"
	   (interactive)
	   (find-file "~/.emacs.d/configuration.org"))

	 (global-set-key (kbd "C-c I") 'para/locate-literate-config)
   #+end_src


** Key Frequency Tracking
   This helps identify frequently used commands which could be bound for faster use.

   #+begin_src emacs-lisp
	 (use-package keyfreq
	   :config
	   (keyfreq-mode 1)
	   (keyfreq-autosave-mode 1))
   #+end_src


* Emacs Interactions
  This section contains customizations which focus on Emacs navigation and interaction.

** Auto Revert Buffers
   In the event something has changed on the system, I want to pull in the updated files. Magit has been good about
   doing this for version controlled files, however I've often noticed some buffer diffs for other files. Time to change
   that.

   #+begin_src emacs-lisp
	 (use-package autorevert
	   :ensure nil
	   :diminish
	   :init (global-auto-revert-mode))
   #+end_src


** Multiple Cursors
   This package lets me spin up multiple cursors across lines or matching patterns which can lead to some pretty
   impressive editing and refactoring feats.

   #+begin_src emacs-lisp
	 (use-package multiple-cursors
	   :ensure t
	   :bind (;; Note that recomended 'C->' and 'C-<' are not characters in the shell.
			  ;; Thus I use their lowercase alternatives
			  ("C-c ."   . mc/mark-next-like-this)
			  ("C-c ,"   . mc/mark-previous-like-this)
			  ("C-c /"   . mc/mark-all-like-this)
			  ("C-c m m" . mc/mark-all-like-this-dwim)
			  ("C-c m a" . mc/edit-beginnings-of-lines)
			  ("C-c m e" . mc/edit-ends-of-lines)
			  ("C-c m s" . mc/mark-sgml-tag-pair)
			  ("C-c m l" . mc/edit-lines)))
   #+end_src



** Helm
   Helm gives us incremental completions and narrowing capabilities that really help find what you're looking for within
   Emacs.

   #+begin_src emacs-lisp
	 (use-package helm
	   :diminish helm-mode
	   :init (progn
			   (require 'helm-config)
			   (helm-mode))
	   :bind (("C-c h"   . helm-command-prefix)
			  ("M-x"     . helm-M-x)
			  ("M-y"     . helm-show-kill-ring)
			  ("C-x b"   . helm-mini)
			  ("C-c h a" . helm-apropos)
			  ("C-c h f" . helm-find-files)
			  ("C-c h o" . helm-occur)
			  ("C-c h m" . helm-man-woman))
	   :config
	   (require 'helm-command)
	   (require 'helm-for-files)
	   (require 'helm-imenu)
	   (require 'helm-semantic)
	   (require 'helm-misc)
	   (setq helm-split-window-inside-p      t
			 helm-M-x-fuzzy-match            t
			 helm-buffers-fuzzy-matching     t
			 helm-recentf-fuzzy-match        t
			 helm-semantic-fuzzy-match       t
			 helm-imenu-fuzzy-match          t
			 helm-apropos-fuzzy-match        t
			 helm-candidate-number-limit   100
			 helm-autoresize-max-height     20
			 helm-autoresize-min-height      0)
	   (add-to-list 'helm-sources-using-default-as-input 'heml-source-man-pages)
	   (helm-autoresize-mode t))
   #+end_src


** Buffer Folding with Origami
   Origami minor-mode enables text folding across Emacs. It's pretty useful, though sometimes slow and sometimes
   buggy. With =origami-reset= you can always unfold everything and reset the file, which has always been enough to
   ignore some of the hiccups.

   #+begin_src emacs-lisp
	 (use-package origami
	   :bind (("C-<tab>" . origami-recursively-toggle-node)
			  ("C-c u"   . origami-open-all-nodes)
			  ("C-c f"   . origami-close-all-nodes)
			  ("C-c n"   . origami-show-only-node)
			  ("C-c r"   . origami-reset))
	   :config
	   (global-origami-mode t))

   #+end_src


** Text Expansion with Abbrev
   Abbrev triggers expansion on pressing the space bar after your word, which is incredibly useful for stream of
   conscious text expansion. I use this mainly to expand acronyms and abbreviations, so I can be lazy typing but still
   create readable text for those not yet familiar with those short-strings. However, this is also extremely useful for
   creating shortcuts for words I type often.

   #+begin_src emacs-lisp
	 (use-package abbrev
	   :ensure nil
	   :diminish abbrev-mode
	   :config
	   (setq abbrev-file-name
			 "~/.emacs.d/abbrev_defs")
	   (setq save-abbrevs t)
	   (if (file-exists-p abbrev-file-name)
		   (quietly-read-abbrev-file)))

	 ;; Add Abbrev-Mode Hooks
	 (dolist (hook '(erc-mode-hook
			 emacs-lisp-mode-hook
			 text-mode-hook
			 org-mode-hook))
	   (add-hook hook (lambda () (abbrev-mode 1))))
	 ;; (setq default-abbrev-mode t) ;; Or, default on everywhere
   #+end_src


** Templating with Yasnippets
   Both for programming and regular editing I have a bunch of snippets for text expansion. It doesn't alwasy seem
   suitable for me to use ~abbrev~, especially for large templates, but that's more of a personal choice than a "can it
   be done" thing.

   So, for anything more than abbreviation expansion or word shortcut expansions I use ~yasnippet~ to tab expand and
   interactively fill out templates.

   #+begin_src emacs-lisp
	 (use-package yasnippet
	   :diminish yas-minor-mode
	   :diminish yas-global-mode
	   :bind (("C-c y r" . yas-reload-all)
			  ("C-c y n" . yas-new-snippet)
			  ("C-c y x" . yas-exit-snippet)
			  ("C-c y d" . yas-describe-tables)
			  ("C-c y v" . yas-visit-snippet-file)
			  ("C-c y l" . yas-load-snippet-buffer-and-close))
	   :config
	   (setq yas-verbosity 1)
	   (yas-global-mode 1))
   #+end_src


** Internet Relay Chat with ERC
   Emacs comes with it's own Internet Relay Chat client, ERC. I use this to chat over IRC from right within Emacs.

   #+begin_src emacs-lisp
	 (use-package erc
	   :defer t
	   :config
	   (setq erc-nick "paraparity"
			 erc-hide-list '("PART" "QUIT" "JOIN" "NICK")
			 erc-server "irc.freenode.net"
			 erc-kill-buffer-on-part t
			 erc-scrolltobottom-mode t
			 erc-autojoin-channels-alist '(("freenode.net" "##programming" "#org-mode"))))
   #+end_src


** TODO Remote Interactions with Tramp
   Emacs comes packaged with a really cool utility I'm desperately underutilizing. More work to be done here still.

   Let's change where Tramp saves things, and use SSH as our default method.

   #+begin_src emacs-lisp
	 (use-package tramp)

	 (set-default 'tramp-auto-save-directory "~/.saves/tramp/")
	 (setq tramp-default-method "ssh")

	 ; TODO: if windows: use PuTTy Plink; if *nix: use ssh
   #+end_src


* Org-Mode Configuration
  Honestly, org-mode is probably my biggest anchor to Emacs. I've tried org-mode-like plugins for other editors and
  IDE's, but nothing compares to the real thing. Enshrined within this section is my configuration and customization of
  Emacs org-mode.

  #+begin_src emacs-lisp
	(use-package org)
	(use-package ob-C :ensure nil)
	(use-package ob-ditaa :ensure nil)
	(use-package ob-dot :ensure nil)
	(use-package ob-js :ensure nil)
	(use-package ob-perl :ensure nil)
	(use-package ob-plantuml :ensure nil)
	(use-package ob-sql :ensure nil)
	(use-package org-agenda :ensure nil)
	(use-package org-capture :ensure nil)
	(use-package org-clock :ensure nil)
	(use-package org-tempo :ensure nil)
	(use-package ox :ensure nil)
	(use-package ox-ascii :ensure nil)
	(use-package ox-asciidoc)
	(use-package ox-html :ensure nil)
	(use-package ox-latex :ensure nil)
	(use-package ox-pandoc)
	(use-package ox-slimhtml)

	(setq org-modules
		  '((org-bbdb org-bibtex org-docview org-eww org-gnus org-habit org-info org-irc org-mhe org-rmail org-tempo org-w3m)))


	(add-hook 'org-mode-hook 'turn-on-auto-fill)
	(add-hook 'org-mode-hook
			  '(lambda () (origami-mode nil)))

	(setq org-src-fontify-natively t
		  org-src-tab-acts-natively t)
  #+end_src

** Org Structure
   This section sets up my org-mode file structure. This involves the root of my org directory, the location of my
   agenda files, and the like.

   #+begin_src emacs-lisp
	 (defvar org-directory "~/org")
	 (defvar org-default-notes-file (concat org-directory "/inbox.org"))
   #+end_src


** Org Linking
   Org-mode supports creating links to various resources across org-mode files and materials online.

   Let's create some short links for things I might reference often.

   #+begin_src emacs-lisp
	 ;; Links - use like: cpan:HTML or rfc-txt:7522
	 (setq org-link-abbrev-alist
		   '(("rfc-txt" . "https://tools.ietf.org/rfc/rfc%s.txt")
			 ("cpan"    . "https://metacpan.org/search?q=%s")
			 ("ese"     . "https://emacs.stackexchange.com/search?q=%s")))
   #+end_src


** Org Todo

*** Keywords
	Org-mode has a set of configurable keywords, both sequenced and typed, which can be added to headlines and cycled
	through to track an arbitrary workflow you define. This is where I define my keywords.

	The default org-mode sequence is as follows:
	#+begin_example
	  ,-> (unmarked) -> TODO -> DONE --.
	  '--------------------------------'
	#+end_example

	However, that's pretty simple and I have something else in mind.

	#+begin_src emacs-lisp
	  (setq org-todo-keywords
			'((sequence "TODO(t)" "STARTED(s)" "WAITING(w@)" "|" "DONE(d)" "DROP(x@)")
			  (sequence "REVIEW(r)"                          "|" "REVIEWED(v)")
			  (sequence "OPEN(o)"                            "|" "CLOSED(c)")))

	  (setq org-todo-keyword-faces
			'(("STARTED" . "cyan")
			  ("MAYBE"   . "purple")
			  ("WAITING" . (:foreground "yellow" :weight bold))
			  ("DROP"    . "DimGray")))
	#+end_src


*** Tags
	Org-mode files and headlines can be tagged to enable searching and cross-correlating information across files and
	directories.

	To support my Emacs implementation of Getting Things Done (GTD), I have a set of tags I use to denote tasks,
	projects, and contexts. For now this is enough, though I think there's still more improvement to make here,
	especially when it comes to searching behavior.

	#+begin_src emacs-lisp
	  (setq org-tag-alist
			'(("@apartment"   . ?A)
			  ("@career"      . ?C)
			  ("@finances"    . ?F)
			  ("@guild"       . ?G)
			  ("@health"      . ?H)
			  ("@learn"       . ?L)
			  ("@network"     . ?N)
			  ("@office"      . ?O)
			  ("@read"        . ?R)
			  ("@self"        . ?S)
			  ("@travel"      . ?V)
			  ("@workstation" . ?W)
			  ("PROJECT"      . ?P)
			  ("TASK"         . ?T)
			  ("NEXT"         . ?X)
			  ("org-journal"  . ?j)))

	  (setq org-tags-exclude-from-inheritance '("PROJECT")
			org-stuck-projects '("+PROJECT/-WAITING-DONE"
								 ("TODO" "STARTED") ()))
	#+end_src

**** TODO Extend Tagging Beyond GTD


** Agenda
   With org-mode to-do items and tags configured, we can start unleashing the real power behind org-mode and configure
   our agendas.

   Org-mode agendas pull from a list of files which I have mostly tucked away under the =agendas= sub-directory within
   my =org-directory=. The structure of these files is mostly informed by the Getting Things Done framework.

   #+begin_src emacs-lisp
	 ;; Agenda Files:
	 (setq org-agenda-files
		   '("~/org/agendas/organizer.org"
			 "~/org/agendas/tickler.org"
			 "~/org/agendas/waiting-on.org"
			 ;;"~/org/agendas/<person>.org"
			 "~/org/agendas/review.org"
			 "~/org/agendas/inbox.org"))
   #+end_src

   Let's also modify some other agenda settings.

   #+begin_src emacs-lisp
	 (setq org-agenda-skip-deadline-if-done t
		   org-agenda-skip-scheduled-if-done t)
   #+end_src

*** Agenda Helpers
	This section contains some helpful functions for working with agenda items.

	A while back I stumbled across Aaron Bieber's blog which has some really helpful posts about Emacs. Particularly of
	interest here is this post: [[https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html][An Agenda for Life with org-mode]]. From it, I've lifted the following helpers.

	#+begin_src emacs-lisp
	  (defun air/org-skip-subtree-if-priority (priority)
		"Skip an agenda subtree if it has a priority of PRIORITY.

		  PRIORITY may be one of the characters ?A, ?B, or ?C."
		(let ((subtree-end (save-excursion (org-end-of-subtree t)))
			  (pri-value (* 1000 (- org-lowest-priority priority)))
			  (pri-current (org-get-priority (thing-at-point 'line t))))
		  (if (= pri-value pri-current)
			  subtree-end
			nil)))

	  (defun air/org-skip-subtree-if-habit ()
		"Skip an agenda entry if it has a STYLE property equal to \"habit\"."
		(let ((subtree-end (save-excursion (org-end-of-subtree t))))
		  (if (string= (org-entry-get nil "STYLE") "habit")
			  subtree-end
			nil)))
	#+end_src


*** Agenda Commands
	Agenda commands are the powerhouse behind org-mode and agendas. These allow you to query across your agenda files
	and surface reports of varying complexity. It's a great way to get exactly the thing you want, with only a few
	keystrokes.

	Agenda commands have the following form:
	#+begin_example
	  (setq org-agenda-custom-commands
			'(
			  ;; (1 key) (2 description (optional)) (3 type of search) (4 search term)
			  ("c" "Desk Work" tags-todo "computer"
			   ((org-agenda-files '("~/org/widgets.org" "~/org/clients.org")) ;; (5 settings (optional))
				(org-agenda-sorting-strategy '(priority-up effort-down)))
			   ("~/computer.html"))                                           ;; (6 export files (optional))
			  ;; ... other commands
			  ))
	#+end_example

	My agenda commands are below.

	#+begin_src emacs-lisp
	  (setq org-agenda-custom-commands
			'(("d" "Daily agenda and all TODOs"
			   ((tags "PRIORITY=\"A\""
					  ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
					   (org-agenda-overriding-header "High-Priority Unfinished Tasks:")))
				(agenda ""
						((org-agenda-span 1)))
				(alltodo ""
						 ((org-agenda-skip-function
						   '(or (air/org-skip-subtree-if-habit)
								(air/org-skip-subtree-if-priority ?A)
								(org-agenda-skip-if nil '(scheduled deadline))))
						  (org-agenda-overriding-header "All Normal Priority Tasks:"))))
			   ((org-agenda-compact-blocks t)))
			  ("D" "Daily Action List"
			   ((agenda ""
						((org-agenda-span 1)
						 (org-agenda-sorting-strategy
						  '((agenda time-up priority-down tag-up)))
						 (org-deadline-warning-ndays 0)))
				))
			  ("w" "Weekly Review"
			   ((agenda ""
						((org-agenda-span 7)))
				(stuck "")
				(tags "PROJECT")
				(todo "WAITING")
				p			  ))
			  ("y" "Someday Maybe"
			   ((todo "MAYBE"
					  ((org-agenda-files '("~/org/maybe.org"))))
				))
			  ("r" "Review"
			   ((todo "REVIEW"
					  ((org-agenda-files '("~/org/review.org"))))
				))
			  ("X" "Upcoming Deadlines"
			   ((agenda ""
						((org-agenda-entry-types '(:deadline))
						 (org-agenda-span 1)
						 (org-deadline-warning-days 60)
						 (org-agenda-time-grid nil)))
				))
			  ("P" "Printed agenda"
			   ((agenda ""
						((org-agenda-span 7)
						 (org-agenda-start-on-weekday nil)
						 (org-agenda-repeating-timestamp-show-all t)
						 (org-agenda-entry-types '(:timestamp :sexp))))
				(agenda ""
						((org-agenda-span 1)
						 (org-deadline-warning-days 7)
						 (org-agenda-todo-keyword-format "[ ]")
						 (org-agenda-scheduled-leaders '("" ""))
						 (org-agenda-prefix-format "%t%s")))
				(todo "TODO"
					  ((org-agenda-prefix-format "[ ] %T: ")
					   (org-agenda-sorting-strategy '(tag-up prority-down))
					   (org-agenda-todo-keyword-format "")
					   (org-agenda-overriding-header "\nTasks by Context\n-----------------\n"))))
			   ((org-agenda-with-colors nil)
				(org-agenda-compact-blocks t)
				(org-agenda-remove-tags t)
				(ps-number-of-columns 2)
				(ps-landscape-mode t))
			   ("~/agenda.ps"))
			  ("Q" . "Custom Queries")
			  ("Qa" "Archive Search"
			   ((search ""
						((org-agenda-files
						  (file-expand-wildcards "~/org/archive/*.org"))))
				))
			  ("QA" "Archive Tags Search"
			   ((org-tags-view ""
							   ((org-agenda-files
								 (file-expand-wildcards "~/org/archive/*.org"))))
				))
			  ))
	#+end_src


** Org Clocking
   Org-mode gives us the ability to track time by clocking in and out of headlines. Combined with todo items and
   agendas, we can really get some value out of this functionality.

   #+begin_src emacs-lisp
	 (setq org-clock-in-switch-to-state "STARTED")
	 (setq org-clock-report-include-clocking-task t)
	 (setq org-log-into-drawer "LOGBOOK")
	 (setq org-clock-into-drawer 1)
	 (setq org-log-done 'time)

	 (setq org-clock-continuously t)
	 (setq org-clock-in-resume t)
	 (setq org-expiry-inactive-timestamps t)
	 (setq org-src-window-setup 'current-window)

	 (org-clock-persistence-insinuate); Resume clocking task when emacs is restarted
   #+end_src


** Org Journal
   Let's set up where my journal files are stored, and the format of the entries.

   #+begin_src emacs-lisp
	 (use-package org-journal
	   :init
	   (setq org-journal-dir "~/org/journal/"
			 org-journal-file-format "%Y%m%d"
			 org-journal-date-format "%e %b %Y (%A)")
	   :config
	   (setq org-journal-date-prefix "#+TITLE: Daily Note for "))
   #+end_src

*** Journal Helpers
	These are functions that will later enable us to interact with org-journal via capture templates, etc...

	#+begin_src emacs-lisp
	  (defun get-journal-file-yesterday ()
		"Gets filename for yesterday's journal entry."
		(let* ((yesterday (time-subtract (current-time) (days-to-time 1)))
			   (daily-name (format-time-string "%Y%m%d" yesterday)))
		  (expand-file-name (concat org-journal-dir daily-name))))

	  (defun journal-file-yesterday ()
		"Create and load a file based on yesterday's date."
		(interactive)
		(find-file (get-journal-file-yesterday)))

	  (defun org-journal-find-location ()
		"Open today's journal.
		  Specify a non-nil prefix to inhibit inserting the heading"
		(org-journal-new-entry t)
		(goto-char (point-min)))
	#+end_src



** Capture Templates
   Capture templates allow us to quickly invoke a key-chord and select a template to capture some thought directly to a
   good home for it. Tasks to my organizer, new journal items to my journal, etc...

   #+begin_src emacs-lisp
	 ;; Org Capture Configuration
	 (defvar org-capture-templates (list))

	 (add-to-list 'org-capture-templates
				  `("t" "Todo" entry (file+headline "~/org/inbox.org" "Tasks")
					"\n* TODO %? :TASK:\n %i\n %a" :empty-lines 1))

	 (add-to-list 'org-capture-templates
				  `("p" "Project" entry (file+headline "~/org/inbox.org" "Projects")
					"\n* TODO %? :PROJECT:\n %i\n %a" :empty-lines 1))

	 (add-to-list 'org-capture-templates
				  `("j" "Journal" entry (function org-journal-find-location)
					"* %(format-time-string org-journal-time-format)%^{Title}\n%i%?"))

	 (add-to-list 'org-capture-templates
				  `("n" "Note" entry (file+headline "~/org/refile.org" "Notes")
					"* %?\n %i\n See: %a" :empty-lines 1))

	 (add-to-list 'org-capture-templates
				  `("T" "Tickler" entry (file+headline "~/org/tickler.org" "Tickler")
					"\n* %i%? \n %U" :empty-lines 1))

	 (add-to-list 'org-capture-templates
				  `("c" "Item to Current Clock" item
					(clock)
					"%i%?" :empty-lines 1))

	 (add-to-list 'org-capture-templates
				  `("r" "Region to Current Clock" plain
					(clock)
					"%i" :immediate-finish t :empty-lines 1))

	 ;;; BEGIN Capture Helpers
	 (defun region-to-clocked-task (start end)
	   "Copies the selected text, from START to END, to the currently clocked in `org-mode` task."
	   (interactive "r")
	   (org-capture-string (buffer-substring-no-properties-start end) "C"))
	 (global-set-key (kbd "C-<F1>") 'region-to-clocked-task)

	 ;; Meeting Focus
	 (defun meeting-notes ()
	   "Call this after creating an `org-mode` heading for a meeting's notes.
		 After calling this function, call 'meeting-done' to reset the environment."
	   (interactive)
	   (outline-mark-subtree)
	   (narrow-to-region (region-beginning) (region-ending))
	   (deactivate-mark)
	   (delete-other-windows)
	   (text-scale-set 2)
	   (fringe-mode 0)
	   (message "When finished taking notes, run meeting-done"))

	 (defun meeting-done ()
	   "Mostly restore the pre-meeting settings."
	   (interactive)
	   (widen)
	   (text-scale-set 0)
	   (fringe-mode 1)
	   (winner-undo))
	 ;;; END Capture Helpers
   #+end_src


** Org Refile
   Despite having some nice capture templates, sometimes things still don't end up in the right place. That, or
   sometimes I just want to move something.

   #+begin_src emacs-lisp
	 (setq org-refile-targets '((org-agenda-files :maxlevel . 6)))
	 ;;(setq org-outline-path-complete-in-steps nil)
	 (setq org-refile-allow-creating-parent-nodes 'confirm)
   #+end_src


** Org-Babel

*** Supporting Tools
	Using org-babel, we can pull in some graphical helper tools to give it some rendering capabilities.

	#+begin_src emacs-lisp
	  (setq org-ditaa-jar-path "/usr/bin/ditaa.jar")
	  (setq org-plantuml-jar-path "/usr/share/plantuml/plantuml.jar")
	#+end_src


*** Displaying Inline Images
	Let's make it so org-babel can display images in org files directly.

	#+begin_src emacs-lisp
	  (defun bh/display-inline-images ()
		"Display inline images."
		(condition-case nil
			(org-display-inline-images)
		  (error nil)))

	  (add-hook 'org-babel-after-execute-hook 'bh/display-inline-images 'append)
	#+end_src


*** Configuring Supported Languages
	I'm only going to configure the subset of languages I use, but there are way more to choose from.

	#+begin_src emacs-lisp
	  (org-babel-do-load-languages
	   'org-babel-load-languages
	   '((C          . t)
		 (ditaa      . t)
		 (dot        . t)
		 (emacs-lisp . t)
		 (gnuplot    . t)
		 (js         . t)
		 (latex      . t)
		 ;;(ledger     . t)
		 (org        . t)
		 (perl       . t)
		 (plantuml   . t)
		 (python     . t)
		 (shell      . t)
		 (sql        . t)))
	#+end_src


*** Final Things
	With org-bable mostly configured, lets plug it into some other stuff.

	#+begin_src emacs-lisp
	  (add-to-list 'org-src-lang-modes (quote ("plantuml" . fundamental)))
	#+end_src


* Development Interactions
  This section contains customizations for development and working within coding environments.

** Editor Config
   See [[https://editorconfig.org/][EditorConfig.org]] for more details. However, this helps me play nice across source repositories, and helps keep
   contributors happily using their own editor/IDE.

   #+begin_src emacs-lisp
	 (use-package editorconfig
	   :ensure t
	   :diminish editorconfig-mode
	   :config
	   (editorconfig-mode 1))
   #+end_src


** TODO Language Server
   The Language Server Protocol (LSP) sets up a contract for an editor (client) to chat with a language server to reduce
   development burden of supporting language interactions across languages and editors. Instead, the server can worry
   about supporting language interactions and any editor with a client can get the benefit of that abstraction.

   Emacs has both the [[https://github.com/emacs-lsp/lsp-mode][lsp-mode]] and [[https://github.com/joaotavora/eglot][eglot]] packages to support client interfaces with various language server
   backends. I've chosen to leverage =lsp-mode= as my language server client.

   #+begin_src emacs-lisp
	 ;; LSP mode configuration
	 (use-package lsp-mode
	   :commands lsp
	   :hook (c++-mode python-mode go-mode-hook)
	   :init
	   (setq lsp-prefer-flymake nil))

	 (use-package lsp-ui :commands lsp-ui-mode)
	 (use-package company-lsp :commands company-lsp)
   #+end_src


** On The Fly Checking
   Fly-Check enables on the fly syntax checking which helps me catch errors as I write them and prompts me to fix them
   immediately. This enforces a tight feedback loop in development.

   #+begin_src emacs-lisp
	 (use-package flycheck)

	 (add-hook 'after-init-hook #'global-flycheck-mode)

	 (setq flycheck-checkers
		   (quote (asciidoc
				   c/c++-cppcheck
				   css-csslint
				   emacs-lisp
				   emacs-lisp-checkdoc
				   handlebars
				   html-tidy
				   javascript-eslint
				   json-jsonlint
				   less
				   make
				   perl
				   perl-perlcritic
				   python-flak8
				   python-pylint
				   rust
				   sh-bash
				   sh-zsh
				   sh-spellcheck
				   tex-chktex
				   tex-lacheck
				   texinfo
				   xml-xmlstarlet
				   xml-xmllint
				   yaml-jayaml)))
	 ;; Others: cfenging chef-foodcritic coffee coffee-coffeelint d-dmd elixir
	 ;;         erlang eruby-erubis go-gofmt go-golint go-vet go-build go-test
	 ;;         haml haskell-ghc haskell-hlint lua php php-phpmd php-phpcs
	 ;;         puppet-parser puppet-lint racket rst rst-sphinx ruby-rubocop
	 ;;         ruby-rubylint ruby ruby-jruby sass scala scss slim verilog-verilator

	 (setq-default flycheck-disabled-checkers
				   '((javascript-jshint
					  javascript-jslint
					  javascript-gjslint
					  c/c++-clang)))

	 ;; Enable C++14 support for GCC
	 (add-hook 'c++-mode-hook (lambda () (setq flycheck-gcc-language-standard "c++14")))

	 ;; Use project relative eslint; see https://emacs.stackexchange.com/questions/21205
	 (defun para/use-eslint-from-node-modules ()
	   "Use project local eslint node modules."
	   (let* ((root (locate-dominating-file
					 (or (buffer-file-name) default-directory)
					 "node_modules"))
			  (eslint (and root
						   (expand-file-name "node_modules/eslint/bin/eslint.js"
											 root))))
		 (when (and eslint (file-executable-p eslint))
		   (setq-local flycheck-javascript-eslint-executable eslint))))

	 (add-hook 'flycheck-mode-hook #'para/use-eslint-from-node-modules)

	 ;; Enable flycheck globally:
	 (add-hook 'after-init-hook #'global-flycheck-mode)

	 ;; See: https://emacs.stackexchange.com/questions/13065
	 ;; (defun setup-flycheck-clang-project-path ()
	 ;;   "Use project local clang."
	 ;;   (let ((root (ignore-errors (projectile-project-root))))
	 ;; 	(when root
	 ;; 	  (add-to-list
	 ;; 	   (make-variable-buffer-local 'flycheck-clang-include-path)
	 ;; 	   root))))

	 ;; (add-hook 'c++-mode-hook 'setup-flycheck-clang-project-path)
   #+end_src


** Company Completions
   Company-mode, or complete any mode, is an extremely useful tool for text/code completion.

   #+begin_src emacs-lisp
	 (use-package company
	   :ensure t
	   :diminish
	   :bind (:map company-active-map
				   ("M-n" . nil)
				   ("M-p" . nil)
				   ("C-n" . company-select-next)
				   ("C-p" . company-select-previous))
	   :init (global-company-mode)
	   :config
	   (setq company-tooltip-align-annotations t
			 company-idle-delay nil
			 company-minimum-prefix-length 2
			 company-require-match nil
			 company-show-numbers t
			 company-tooltip-limit 20)
	   (with-eval-after-load 'company
		 (global-set-key (kbd "C-c SPC") 'company-complete)))
   #+end_src

   It also plugs into ~lsp-mode~ which I'll be setting up later.
   #+begin_src emacs-lisp
	 (use-package company-lsp
	   :after (company lsp-mode)
	   :commands company-lsp
	   :config
	   (push 'company-lsp company-backends))
   #+end_src


** Projectile Project Management
   Projectile allows for project interaction from within Emacs. Additionally, it can hook into other powerful search
   utilities to really kick up project navigation.

   #+begin_src emacs-lisp
	 (use-package projectile
	   :ensure t
	   :config
	   (setq projectile-completion-system 'helm)
	   (setq projectile-switch-project-action 'helm-projectile)
	   (setq projectile-enable-caching t)
	   (setq projectile-globally-ignored-directories
			 '(".git" "node_modules" "__pycache__" ".vs"))
	   (setq projectile-globally-ignored-file-suffixes
			 '("#" "~" ".swp" ".o" ".so" ".exe" ".dll" ".elc" ".pyc" ".jar"))
	   (setq projectile-globally-ignored-files
			 '("TAGS" "tags"))
	   (with-eval-after-load "projectile"
		 (projectile-mode)
		 (helm-projectile-on)))

	 (use-package helm-projectile)

   #+end_src


** TODO Magit and Version Control
   Magical Git interactions in Emacs.

   #+begin_src emacs-lisp
	 (setq vc-handled-backends (delq 'Git vc-handled-backends))

	 (use-package magit
	   :ensure t
	   :defer t
	   :bind ("C-x g" . magit-status))
   #+end_src


** TODO Treemacs


** Language Configurations

*** Mode Bindings by Filetype
	Make sure certain files open in certain modes.

	#+begin_src emacs-lisp
	  (add-to-list 'auto-mode-alist '("\\.py$"          . python-mode))
	  (add-to-list 'auto-mode-alist '("\\.org$"         . org-mode))
	  (add-to-list 'auto-mode-alist '("\\.ts$"          . typescript-mode))
	  (add-to-list 'auto-mode-alist '("\\.css$"         . css-mode))
	  (add-to-list 'auto-mode-alist '("\\.md$"          . markdown-mode))
	  (add-to-list 'auto-mode-alist '("\\.markdown$"    . markdown-mode))
	  (add-to-list 'auto-mode-alist '("\\.hbs$"         . handlebars-mode))
	  (add-to-list 'auto-mode-alist '("\\.README\\.md$" . gfm-mode))
	  (add-to-list 'auto-mode-alist '("Jenkinsfile$"    . groovy-mode))
	#+end_src


*** Perl Customizations
	I used to write mostly in Perl for work, and ~cperl-mode~ was what my Emacs wielding colleagues used at my
	employer. It was definitely better than the Vanilla Emacs defaults.

	#+begin_src emacs-lisp
	  (use-package cperl-mode)

	  (defalias 'perl-mode 'cperl-mode)
	  (defvaralias 'c-basic-offset 'tab-width)
	  (defvaralias 'cperl-indent-level 'tab-width)

	  ;; Override perl-mode with cperl-mode
	  (mapc
	   (lambda (pair)
		 (if (eq (cdr pair) 'perl-mode)
			 (setcdr pair 'cperl-mode)))
	   (append auto-mode-alist interpreter-mode-alist))
	#+end_src


*** Javascript
	From time to time I've developed either tangentially or immersively in Javascript, both in the Web and in
	Node. ~js2-mode~ has been good to me for that. I tried ~js3-mode~, but found it lacked features and had fallen out
	of support. I'm somewhat eyeing ~indium~, but would likely prefer to just use a ~lsp-mode~ solution that also
	supports Typescript.

	#+begin_src emacs-lisp
	  (use-package js2-mode
		:defer t
		:mode "\\.js$"
		:config
		(require 'js2-refactor)
		(define-key js2-mode-map (kbd "M-.") nil)
		(add-hook 'js2-mode-hook #'js2-refactor-mode)
		(js2r-add-keybindings-with-prefix "C-c C-r")
		(define-key js2-mode-map (kbd "C-k") #'js2r-kill)
		(add-hook 'js2-mode-hook
				  (lambda ()
					(add-hook 'xref-backend-functions #'xref-js2-xref-backend nil t)))
		(add-hook 'js2-mode-hook
				  (lambda ()
					(setq mode-name "js2"))))
	#+end_src


* More Emacs Modes
** Ledger - Command Line Accounting
   Ledger, the command line double booking entry system. A geeky way to track your finances, with support in Emacs via
   ~ledger-mode~!

   #+begin_src emacs-lisp :tangle no
	 (use-package ledger-mode
	   :mode ("\\.ledger$")
	   :bind (:map ledger-mode-map
				   ("C-x C-s" . para/ledger-save))
	   :preface
	   (defun para/ledger-save ()
		 "Automatically clean the ledger buffer at each save."
		 (interactive)
		 (save-excursion
		   (when (buffer-modified-p)
			 (with-demoted-errors (ledger-mode-clean-buffer))
			 (save-buffer))))
	   :init
	   (setq ledger-post-amount-alignment-column 80))

	 (use-package flycheck-ledger
	   :after ledger-mode)
   #+end_src


* More Emacs Tools
** PDF-Tools
   PDF-Tools enable PDF viewing within Emacs, so I don't have to have a second application open to read and take notes
   on PDFs. Just one more reason to neve leave Emacs.

   #+begin_src emacs-lisp
	 (use-package pdf-tools
	   :pin manual
	   :config
	   (setq-default pdf-view-display-size 'fit-page)
	   (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward))
   #+end_src


* TODO Helper Functions
  This section contains custom functions I'll sometimes invoke. These should probably live elsewhere, but for now, this
  is their home.

  #+begin_src emacs-lisp
	;; Regardless of which buffer you're in, jump to the active minibuffer
	(defun switch-to-minibuffer ()
	  "Switch to minibuffer window."
	  (interactive)
	  (if (active-minibuffer-window)
		  (select-window (active-minibuffer-window))
		(error "Minibuffer is not active")))

	(defun occur-non-ascii ()
	  "Find any non-ascii characters in the current buffer."
	  (interactive)
	  (occur "[[:nonascii:]]"))
  #+end_src


* TODO Keybinding Overrides
  - Refactor to their relavant mode configurations. Only defaults or net new bindings should remain here.

  This section contains my keybinding overrides. After all the work we've done to get things set up or customized to my
  liking, I still need to sing to my own tune and play my own chords.

  #+begin_src emacs-lisp
	;; Buffer Key Bindings
	(global-set-key (kbd "C-S-<left>") 'shrink-window-horizontally)
	(global-set-key (kbd "C-S-<right>") 'enlarge-window-horizontally)
	(global-set-key (kbd "C-S-<down>") 'shrink-window)
	(global-set-key (kbd "C-S-<up>") 'enlarge-window)
	(global-set-key (kbd "C-x |") 'window-toggle-split-direction)
	(global-set-key (kbd "C-c o") 'switch-to-minibuffer)
	(global-set-key (kbd "<f8>") 'flyspell-buffer)
	(global-set-key (kbd "<f6>") 'speedbar)

	;; Org-Mode Keybindings
	(global-set-key (kbd "C-c a") 'org-agenda)
	(global-set-key (kbd "C-c c") 'org-capture)
	(global-set-key (kbd "C-c l") 'org-store-link)

	;; Elfeed Keybindings
	(global-set-key (kbd "C-x w") 'elfeed)

	;; Misc Keybindings
	(global-set-key (kbd "C-x #") 'comment-or-uncomment-region)
	(global-set-key (kbd "C-c d") 'duplicate-current-line-or-region)
	;;(global-set-key (kbd "M-.") 'find-tag-other-window)

	;; Modal Key Bindings
	(add-hook 'cperl-mode-hook
			  (lambda ()
				(local-set-key (kbd "C-h f") 'cperl-perldoc)))

	;; Kill the bane of my fat-fingers
	(global-unset-key (kbd "C-z"))
	(global-unset-key (kbd "C-x C-z"))
  #+end_src

** Enable Full Keboard Num-Pad
   Unfortunately I've found Emacs doesn't natively support full size keyboards, however this allows us to get our numpad
   working.

   #+begin_src emacs-lisp
	 ;; Numpad Key Bindings
	 (global-set-key "\eOp" "0")
	 (global-set-key "\eOq" "1")
	 (global-set-key "\eOr" "2")
	 (global-set-key "\eOs" "3")
	 (global-set-key "\eOt" "4")
	 (global-set-key "\eOu" "5")
	 (global-set-key "\eOv" "6")
	 (global-set-key "\eOw" "7")
	 (global-set-key "\eOx" "8")
	 (global-set-key "\eOy" "9")
	 (global-set-key "\eOl" "+")
	 (global-set-key "\eOn" ".")
   #+end_src


* Final Countdown
  This section contains the last moment configurations that wrap up my personal customization and Emacs load. Here we'll
  kill mode-line clutter and start up the Emacs server.

  #+begin_src emacs-lisp
	;; Make it so I can recover old sessions after close or reboot
	(desktop-save-mode 1)

	;; Start the Emacs server
	(require 'server)
	(unless (server-running-p)
	  (defvar server-name (concat "server"(number-to-string (emacs-pid))))
	  (ignore-errors (server-start))

	  ;; Set the environment variables for *shell*.
	  (setenv "EDITOR" (concat "~/usr/local/bin/emacsclient -s " server-name)))

	;;(put 'narrow-to-region 'disabled nil)
  #+end_src


* Configuration Reading
  That's mostly it folks. Configuration is done, the rest are future works. This section collects other articles or
  configurations I've stumbled across and bookmarked for "eventual" reading.

  - https://katherine.cox-buday.com/blog/2015/03/14/writing-specs-with-org-mode/
  - http://kitchingroup.cheme.cmu.edu/blog/category/org-mode/
  - https://ladicle.com/post/config/#screenshot
  - https://orgmode.org/worg/org-web.html
  - https://github.com/ianpan870102/.emacs.d
  - http://emacs.cafe/emacs/orgmode/gtd/2017/06/30/orgmode-gtd.html
  - https://joshrollinswrites.com/emacsorg/org-capture-template-1/
  - http://www.howardism.org/Technical/Emacs/getting-boxes-done.html
  - http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html
  - https://orgmode.org/worg/org-tutorials/org-latex-export.html
  - https://www.gnu.org/software/tramp/#Configuration
  - http://doc.norang.ca/org-mode.html

  Collections:
  - https://orgmode.org/worg/org-blog-articles.html


** TODO List [0/25]
   - [ ] https://github.com/hungptit/tools and integration w/ Emacs
   - [ ] https://github.com/yjwen/org-reveal
   - [ ] https://github.com/fniessen/org-html-themes
   - [ ] hydra
   - [ ] ivy
   - [ ] treemacs
   - [ ] lsp-mode, lsp-ui, company-lsp, dap-mode
   - [ ] org-journal
   - [ ] org-brain
   - [ ] bbdb
   - [ ] ox-slimhtml
   - [ ] realgud
   - [ ] bookmarks
   - [ ] epg
   - [ ] semantic
   - [ ] tramp, docker-tramp
   - [ ] docker-tramp
   - [ ] fzf - fuzzy file finding
   - [ ] MacOS X / Linux config
   - [ ] exec-path-from-shell
   - [ ] sx - stack exchange integration?
   - [ ] restclinet
   - [ ] org-mode blogging
   - [ ] markdown mode
   - [ ] straight.el (some kind of package management?)


** Explore List [0/1]
   - [ ] https://gitlab.com/jaor/geiser


* Other Reading
  - https://lispcookbook.github.io/cl-cookbook/emacs-ide.html
  - https://edwardtufte.github.io/tufte-css/
